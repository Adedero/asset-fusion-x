import { z } from "zod";
import type { Prisma } from "@prisma/client";

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const TransactionIsolationLevelSchema = z.enum([
  "ReadUncommitted",
  "ReadCommitted",
  "RepeatableRead",
  "Serializable",
]);

export const UserScalarFieldEnumSchema = z.enum([
  "id",
  "name",
  "email",
  "emailVerified",
  "image",
  "role",
  "banned",
  "banReason",
  "banExpires",
  "createdAt",
  "updatedAt",
]);

export const SessionScalarFieldEnumSchema = z.enum([
  "id",
  "userId",
  "token",
  "expiresAt",
  "ipAddress",
  "userAgent",
  "impersonatedBy",
  "createdAt",
  "updatedAt",
]);

export const AccountScalarFieldEnumSchema = z.enum([
  "id",
  "userId",
  "accountId",
  "providerId",
  "accessToken",
  "refreshToken",
  "accessTokenExpiresAt",
  "refreshTokenExpiresAt",
  "scope",
  "idToken",
  "password",
  "createdAt",
  "updatedAt",
]);

export const VerificationScalarFieldEnumSchema = z.enum([
  "id",
  "identifier",
  "value",
  "expiresAt",
  "createdAt",
  "updatedAt",
]);

export const ProfileScalarFieldEnumSchema = z.enum([
  "id",
  "userId",
  "address",
  "country",
  "state",
  "city",
  "postalCode",
  "governmentId",
  "governmentIdType",
  "governmentIdExt",
  "kycStatus",
  "createdAt",
  "updatedAt",
]);

export const BusinessProfileScalarFieldEnumSchema = z.enum([
  "id",
  "financialAccountId",
  "address",
  "creationMonth",
  "creationYear",
  "proofOfAddress",
  "proofOfAddressExt",
  "certificate",
  "certificateExt",
  "approved",
  "createdAt",
  "updatedAt",
]);

export const FinancialAccountScalarFieldEnumSchema = z.enum([
  "id",
  "creatorId",
  "name",
  "number",
  "status",
  "type",
  "ownership",
  "balance",
  "totalTransactions",
  "totalInvestments",
  "firstTransactionAt",
  "lastTransactionAt",
  "closedAt",
  "dormantAt",
  "createdAt",
  "updatedAt",
]);

export const AccountUserScalarFieldEnumSchema = z.enum([
  "id",
  "userId",
  "financialAccountId",
  "role",
  "ownership",
  "autosign",
  "createdAt",
  "updatedAt",
]);

export const JointAccountRequestScalarFieldEnumSchema = z.enum([
  "id",
  "creatorId",
  "recipientName",
  "recipientEmail",
  "role",
  "ownership",
  "recipientId",
  "financialAccountId",
  "description",
  "lastReminderAt",
  "reminderCount",
  "status",
  "createdAt",
  "updatedAt",
]);

export const JointAccountModRequestScalarFieldEnumSchema = z.enum([
  "id",
  "creatorId",
  "financialAccountId",
  "type",
  "transactionId",
  "description",
  "createdAt",
  "updatedAt",
]);

export const JointAccountModRequestApprovalScalarFieldEnumSchema = z.enum([
  "id",
  "jointAccountModRequestId",
  "approverId",
  "status",
  "createdAt",
  "updatedAt",
]);

export const InvestmentPlanScalarFieldEnumSchema = z.enum([
  "id",
  "name",
  "category",
  "minimumDeposit",
  "maximumDeposit",
  "duration",
  "profitDistribution",
  "percentageTotalReturn",
  "percentagePeriodicReturn",
  "terminationFee",
  "createdAt",
  "updatedAt",
]);

export const InvestmentScalarFieldEnumSchema = z.enum([
  "id",
  "financialAccountId",
  "investorId",
  "deposit",
  "investmentName",
  "totalProfit",
  "profitCount",
  "status",
  "pausedAt",
  "pausedReason",
  "closedAt",
  "closedReason",
  "terminatedAt",
  "terminatedReason",
  "category",
  "daysCompleted",
  "duration",
  "totalReturn",
  "periodicReturn",
  "profitDistribution",
  "terminationFee",
  "createdAt",
  "updatedAt",
]);

export const TransactionScalarFieldEnumSchema = z.enum([
  "id",
  "amount",
  "currency",
  "USDAmount",
  "rate",
  "charges",
  "financialAccountId",
  "type",
  "initiatorAccountId",
  "recipientAccountId",
  "investmentId",
  "status",
  "parentTransactionId",
  "approvedAt",
  "failedAt",
  "failReason",
  "depositWalletAddress",
  "depositWalletAddressNetwork",
  "withdrawalWalletAddress",
  "withdrawalWalletAddressNetwork",
  "bank",
  "bankAccount",
  "description",
  "createdAt",
  "updatedAt",
]);

export const NotificationScalarFieldEnumSchema = z.enum([
  "id",
  "title",
  "body",
  "bodyType",
  "userId",
  "financialAccountId",
  "link",
  "isRead",
  "createdAt",
  "updatedAt",
]);

export const CurrencyScalarFieldEnumSchema = z.enum([
  "id",
  "name",
  "symbol",
  "image",
  "rate",
  "rateUpdatedAt",
  "walletAddress",
  "walletAddressNetwork",
  "allowWithdrawal",
  "withdrawalCharge",
  "createdAt",
  "updatedAt",
]);

export const SettingsScalarFieldEnumSchema = z.enum(["id", "allowWithdrawals"]);

export const SortOrderSchema = z.enum(["asc", "desc"]);

export const QueryModeSchema = z.enum(["default", "insensitive"]);

export const NullsOrderSchema = z.enum(["first", "last"]);

export const UserRoleSchema = z.enum(["admin", "user"]);

export type UserRoleType = `${z.infer<typeof UserRoleSchema>}`;

export const KycStatusSchema = z.enum([
  "pending",
  "verified",
  "rejected",
  "resubmit",
]);

export type KycStatusType = `${z.infer<typeof KycStatusSchema>}`;

export const GovernmentIdTypeSchema = z.enum([
  "international_passport",
  "national_id",
  "driving_license",
]);

export type GovernmentIdTypeType = `${z.infer<typeof GovernmentIdTypeSchema>}`;

export const AccountTypeSchema = z.enum(["personal", "business"]);

export type AccountTypeType = `${z.infer<typeof AccountTypeSchema>}`;

export const AccountOwnershipSchema = z.enum(["single", "joint"]);

export type AccountOwnershipType = `${z.infer<typeof AccountOwnershipSchema>}`;

export const AccountStatusSchema = z.enum(["active", "dormant", "closed"]);

export type AccountStatusType = `${z.infer<typeof AccountStatusSchema>}`;

export const AccountUserRoleSchema = z.enum([
  "owner",
  "co_owner",
  "manager",
  "admin",
  "accountant",
  "investor",
  "contributor",
  "legal_guardian",
  "signatory",
]);

export type AccountUserRoleType = `${z.infer<typeof AccountUserRoleSchema>}`;

export const JointAccountRequestStatusSchema = z.enum([
  "pending",
  "accepted",
  "rejected",
]);

export type JointAccountRequestStatusType =
  `${z.infer<typeof JointAccountRequestStatusSchema>}`;

export const JointAccountModRequestTypeSchema = z.enum([
  "transfer",
  "withdrawal",
  "name_change",
]);

export type JointAccountModRequestTypeType =
  `${z.infer<typeof JointAccountModRequestTypeSchema>}`;

export const ProfitDistributionSchema = z.enum([
  "daily",
  "weekly",
  "bi_weekly",
  "monthly",
]);

export type ProfitDistributionType =
  `${z.infer<typeof ProfitDistributionSchema>}`;

export const InvestmentPlanCategorySchema = z.enum([
  "forex",
  "stocks",
  "real_estate",
  "bonds",
  "commodities",
  "cryptocurrencies",
  "derivatives",
]);

export type InvestmentPlanCategoryType =
  `${z.infer<typeof InvestmentPlanCategorySchema>}`;

export const InvestmentStatusSchema = z.enum([
  "open",
  "closed",
  "paused",
  "terminated",
]);

export type InvestmentStatusType = `${z.infer<typeof InvestmentStatusSchema>}`;

export const TransactionTypeSchema = z.enum([
  "deposit",
  "withdrawal",
  "transfer",
  "investment",
  "profit",
]);

export type TransactionTypeType = `${z.infer<typeof TransactionTypeSchema>}`;

export const TransactionStatusSchema = z.enum([
  "pending",
  "successfull",
  "reversed",
  "failed",
]);

export type TransactionStatusType =
  `${z.infer<typeof TransactionStatusSchema>}`;

export const TransactionMediumSchema = z.enum(["wire", "crypto"]);

export type TransactionMediumType =
  `${z.infer<typeof TransactionMediumSchema>}`;

export const NotificationBodyTypeSchema = z.enum(["string", "html"]);

export type NotificationBodyTypeType =
  `${z.infer<typeof NotificationBodyTypeSchema>}`;

/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const UserSchema = z.object({
  role: UserRoleSchema,
  id: z.string().uuid(),
  name: z.string(),
  email: z.string(),
  emailVerified: z.boolean(),
  image: z.string().nullable(),
  banned: z.boolean().nullable(),
  banReason: z.string().nullable(),
  banExpires: z.coerce.date().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type User = z.infer<typeof UserSchema>;

/////////////////////////////////////////
// SESSION SCHEMA
/////////////////////////////////////////

export const SessionSchema = z.object({
  id: z.string().uuid(),
  userId: z.string(),
  token: z.string(),
  expiresAt: z.coerce.date(),
  ipAddress: z.string().nullable(),
  userAgent: z.string().nullable(),
  impersonatedBy: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Session = z.infer<typeof SessionSchema>;

/////////////////////////////////////////
// ACCOUNT SCHEMA
/////////////////////////////////////////

export const AccountSchema = z.object({
  id: z.string().uuid(),
  userId: z.string(),
  accountId: z.string(),
  providerId: z.string(),
  accessToken: z.string().nullable(),
  refreshToken: z.string().nullable(),
  accessTokenExpiresAt: z.coerce.date().nullable(),
  refreshTokenExpiresAt: z.coerce.date().nullable(),
  scope: z.string().nullable(),
  idToken: z.string().nullable(),
  password: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Account = z.infer<typeof AccountSchema>;

/////////////////////////////////////////
// VERIFICATION SCHEMA
/////////////////////////////////////////

export const VerificationSchema = z.object({
  id: z.string().uuid(),
  identifier: z.string(),
  value: z.string(),
  expiresAt: z.coerce.date(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Verification = z.infer<typeof VerificationSchema>;

/////////////////////////////////////////
// PROFILE SCHEMA
/////////////////////////////////////////

export const ProfileSchema = z.object({
  governmentIdType: GovernmentIdTypeSchema.nullable(),
  kycStatus: KycStatusSchema.nullable(),
  id: z.string().uuid(),
  userId: z.string(),
  address: z.string().nullable(),
  country: z.string().nullable(),
  state: z.string().nullable(),
  city: z.string().nullable(),
  postalCode: z.string().nullable(),
  governmentId: z.string().nullable(),
  governmentIdExt: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Profile = z.infer<typeof ProfileSchema>;

/////////////////////////////////////////
// BUSINESS PROFILE SCHEMA
/////////////////////////////////////////

export const BusinessProfileSchema = z.object({
  id: z.string().uuid(),
  financialAccountId: z.string(),
  address: z.string().nullable(),
  creationMonth: z.string().nullable(),
  creationYear: z.number().int().nullable(),
  proofOfAddress: z.string().nullable(),
  proofOfAddressExt: z.string().nullable(),
  certificate: z.string().nullable(),
  certificateExt: z.string().nullable(),
  approved: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type BusinessProfile = z.infer<typeof BusinessProfileSchema>;

/////////////////////////////////////////
// FINANCIAL ACCOUNT SCHEMA
/////////////////////////////////////////

export const FinancialAccountSchema = z.object({
  status: AccountStatusSchema,
  type: AccountTypeSchema,
  ownership: AccountOwnershipSchema,
  id: z.string().uuid(),
  creatorId: z.string(),
  name: z.string(),
  number: z.string(),
  balance: z.number(),
  totalTransactions: z.number().int(),
  totalInvestments: z.number().int(),
  firstTransactionAt: z.coerce.date().nullable(),
  lastTransactionAt: z.coerce.date().nullable(),
  closedAt: z.coerce.date().nullable(),
  dormantAt: z.coerce.date().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type FinancialAccount = z.infer<typeof FinancialAccountSchema>;

/////////////////////////////////////////
// ACCOUNT USER SCHEMA
/////////////////////////////////////////

export const AccountUserSchema = z.object({
  role: AccountUserRoleSchema,
  id: z.string().uuid(),
  userId: z.string(),
  financialAccountId: z.string(),
  ownership: z.number(),
  autosign: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type AccountUser = z.infer<typeof AccountUserSchema>;

/////////////////////////////////////////
// JOINT ACCOUNT REQUEST SCHEMA
/////////////////////////////////////////

export const JointAccountRequestSchema = z.object({
  role: AccountUserRoleSchema,
  status: JointAccountRequestStatusSchema,
  id: z.string().uuid(),
  creatorId: z.string(),
  recipientName: z.string(),
  recipientEmail: z.string(),
  ownership: z.number(),
  recipientId: z.string().nullable(),
  financialAccountId: z.string(),
  description: z.string().nullable(),
  lastReminderAt: z.coerce.date().nullable(),
  reminderCount: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type JointAccountRequest = z.infer<typeof JointAccountRequestSchema>;

/////////////////////////////////////////
// JOINT ACCOUNT MOD REQUEST SCHEMA
/////////////////////////////////////////

export const JointAccountModRequestSchema = z.object({
  type: JointAccountModRequestTypeSchema,
  id: z.string().uuid(),
  creatorId: z.string(),
  financialAccountId: z.string(),
  transactionId: z.string().nullable(),
  description: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type JointAccountModRequest = z.infer<
  typeof JointAccountModRequestSchema
>;

/////////////////////////////////////////
// JOINT ACCOUNT MOD REQUEST APPROVAL SCHEMA
/////////////////////////////////////////

export const JointAccountModRequestApprovalSchema = z.object({
  status: JointAccountRequestStatusSchema,
  id: z.string().uuid(),
  jointAccountModRequestId: z.string(),
  approverId: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type JointAccountModRequestApproval = z.infer<
  typeof JointAccountModRequestApprovalSchema
>;

/////////////////////////////////////////
// INVESTMENT PLAN SCHEMA
/////////////////////////////////////////

export const InvestmentPlanSchema = z.object({
  category: InvestmentPlanCategorySchema,
  profitDistribution: ProfitDistributionSchema,
  id: z.string().uuid(),
  name: z.string(),
  minimumDeposit: z.number(),
  maximumDeposit: z.number(),
  duration: z.number().int(),
  percentageTotalReturn: z.number(),
  percentagePeriodicReturn: z.number(),
  terminationFee: z.number(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type InvestmentPlan = z.infer<typeof InvestmentPlanSchema>;

/////////////////////////////////////////
// INVESTMENT SCHEMA
/////////////////////////////////////////

export const InvestmentSchema = z.object({
  status: InvestmentStatusSchema,
  category: InvestmentPlanCategorySchema,
  profitDistribution: ProfitDistributionSchema,
  id: z.string().uuid(),
  financialAccountId: z.string(),
  investorId: z.string(),
  deposit: z.number(),
  investmentName: z.string(),
  totalProfit: z.number(),
  profitCount: z.number().int(),
  pausedAt: z.coerce.date().nullable(),
  pausedReason: z.string().nullable(),
  closedAt: z.coerce.date().nullable(),
  closedReason: z.string().nullable(),
  terminatedAt: z.coerce.date().nullable(),
  terminatedReason: z.string().nullable(),
  daysCompleted: z.number().int(),
  duration: z.number().int(),
  totalReturn: z.number(),
  periodicReturn: z.number(),
  terminationFee: z.number(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Investment = z.infer<typeof InvestmentSchema>;

/////////////////////////////////////////
// TRANSACTION SCHEMA
/////////////////////////////////////////

export const TransactionSchema = z.object({
  type: TransactionTypeSchema,
  status: TransactionStatusSchema,
  id: z.string().uuid(),
  amount: z.number(),
  currency: z.string(),
  USDAmount: z.number(),
  rate: z.number(),
  charges: z.number(),
  financialAccountId: z.string(),
  initiatorAccountId: z.string(),
  recipientAccountId: z.string().nullable(),
  investmentId: z.string().nullable(),
  parentTransactionId: z.string().nullable(),
  approvedAt: z.coerce.date().nullable(),
  failedAt: z.coerce.date().nullable(),
  failReason: z.string().nullable(),
  depositWalletAddress: z.string().nullable(),
  depositWalletAddressNetwork: z.string().nullable(),
  withdrawalWalletAddress: z.string().nullable(),
  withdrawalWalletAddressNetwork: z.string().nullable(),
  bank: z.string().nullable(),
  bankAccount: z.string().nullable(),
  description: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Transaction = z.infer<typeof TransactionSchema>;

/////////////////////////////////////////
// NOTIFICATION SCHEMA
/////////////////////////////////////////

export const NotificationSchema = z.object({
  bodyType: NotificationBodyTypeSchema,
  id: z.string().uuid(),
  title: z.string(),
  body: z.string(),
  userId: z.string().nullable(),
  financialAccountId: z.string().nullable(),
  link: z.string().nullable(),
  isRead: z.boolean(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Notification = z.infer<typeof NotificationSchema>;

/////////////////////////////////////////
// CURRENCY SCHEMA
/////////////////////////////////////////

export const CurrencySchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  symbol: z.string(),
  image: z.string().nullable(),
  rate: z.number(),
  rateUpdatedAt: z.coerce.date().nullable(),
  walletAddress: z.string().nullable(),
  walletAddressNetwork: z.string().nullable(),
  allowWithdrawal: z.boolean(),
  withdrawalCharge: z.number(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Currency = z.infer<typeof CurrencySchema>;

/////////////////////////////////////////
// SETTINGS SCHEMA
/////////////////////////////////////////

export const SettingsSchema = z.object({
  id: z.string().uuid(),
  allowWithdrawals: z.boolean(),
});

export type Settings = z.infer<typeof SettingsSchema>;

/////////////////////////////////////////
// SELECT & INCLUDE
/////////////////////////////////////////

// USER
//------------------------------------------------------

export const UserIncludeSchema: z.ZodType<Prisma.UserInclude> = z
  .object({
    profile: z.union([z.boolean(), z.lazy(() => ProfileArgsSchema)]).optional(),
    sessions: z
      .union([z.boolean(), z.lazy(() => SessionFindManyArgsSchema)])
      .optional(),
    accounts: z
      .union([z.boolean(), z.lazy(() => AccountFindManyArgsSchema)])
      .optional(),
    createdAccounts: z
      .union([z.boolean(), z.lazy(() => FinancialAccountFindManyArgsSchema)])
      .optional(),
    accountMemberships: z
      .union([z.boolean(), z.lazy(() => AccountUserFindManyArgsSchema)])
      .optional(),
    createdJointAccountRequests: z
      .union([z.boolean(), z.lazy(() => JointAccountRequestFindManyArgsSchema)])
      .optional(),
    receivedJointAccountRequests: z
      .union([z.boolean(), z.lazy(() => JointAccountRequestFindManyArgsSchema)])
      .optional(),
    createdJointAccountModRequests: z
      .union([
        z.boolean(),
        z.lazy(() => JointAccountModRequestFindManyArgsSchema),
      ])
      .optional(),
    notifications: z
      .union([z.boolean(), z.lazy(() => NotificationFindManyArgsSchema)])
      .optional(),
    approvedJointAccountModRequests: z
      .union([
        z.boolean(),
        z.lazy(() => JointAccountModRequestApprovalFindManyArgsSchema),
      ])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const UserArgsSchema: z.ZodType<Prisma.UserDefaultArgs> = z
  .object({
    select: z.lazy(() => UserSelectSchema).optional(),
    include: z.lazy(() => UserIncludeSchema).optional(),
  })
  .strict();

export const UserCountOutputTypeArgsSchema: z.ZodType<Prisma.UserCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => UserCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const UserCountOutputTypeSelectSchema: z.ZodType<Prisma.UserCountOutputTypeSelect> =
  z
    .object({
      sessions: z.boolean().optional(),
      accounts: z.boolean().optional(),
      createdAccounts: z.boolean().optional(),
      accountMemberships: z.boolean().optional(),
      createdJointAccountRequests: z.boolean().optional(),
      receivedJointAccountRequests: z.boolean().optional(),
      createdJointAccountModRequests: z.boolean().optional(),
      notifications: z.boolean().optional(),
      approvedJointAccountModRequests: z.boolean().optional(),
    })
    .strict();

export const UserSelectSchema: z.ZodType<Prisma.UserSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    email: z.boolean().optional(),
    emailVerified: z.boolean().optional(),
    image: z.boolean().optional(),
    role: z.boolean().optional(),
    banned: z.boolean().optional(),
    banReason: z.boolean().optional(),
    banExpires: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    profile: z.union([z.boolean(), z.lazy(() => ProfileArgsSchema)]).optional(),
    sessions: z
      .union([z.boolean(), z.lazy(() => SessionFindManyArgsSchema)])
      .optional(),
    accounts: z
      .union([z.boolean(), z.lazy(() => AccountFindManyArgsSchema)])
      .optional(),
    createdAccounts: z
      .union([z.boolean(), z.lazy(() => FinancialAccountFindManyArgsSchema)])
      .optional(),
    accountMemberships: z
      .union([z.boolean(), z.lazy(() => AccountUserFindManyArgsSchema)])
      .optional(),
    createdJointAccountRequests: z
      .union([z.boolean(), z.lazy(() => JointAccountRequestFindManyArgsSchema)])
      .optional(),
    receivedJointAccountRequests: z
      .union([z.boolean(), z.lazy(() => JointAccountRequestFindManyArgsSchema)])
      .optional(),
    createdJointAccountModRequests: z
      .union([
        z.boolean(),
        z.lazy(() => JointAccountModRequestFindManyArgsSchema),
      ])
      .optional(),
    notifications: z
      .union([z.boolean(), z.lazy(() => NotificationFindManyArgsSchema)])
      .optional(),
    approvedJointAccountModRequests: z
      .union([
        z.boolean(),
        z.lazy(() => JointAccountModRequestApprovalFindManyArgsSchema),
      ])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// SESSION
//------------------------------------------------------

export const SessionIncludeSchema: z.ZodType<Prisma.SessionInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

export const SessionArgsSchema: z.ZodType<Prisma.SessionDefaultArgs> = z
  .object({
    select: z.lazy(() => SessionSelectSchema).optional(),
    include: z.lazy(() => SessionIncludeSchema).optional(),
  })
  .strict();

export const SessionSelectSchema: z.ZodType<Prisma.SessionSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    token: z.boolean().optional(),
    expiresAt: z.boolean().optional(),
    ipAddress: z.boolean().optional(),
    userAgent: z.boolean().optional(),
    impersonatedBy: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

// ACCOUNT
//------------------------------------------------------

export const AccountIncludeSchema: z.ZodType<Prisma.AccountInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

export const AccountArgsSchema: z.ZodType<Prisma.AccountDefaultArgs> = z
  .object({
    select: z.lazy(() => AccountSelectSchema).optional(),
    include: z.lazy(() => AccountIncludeSchema).optional(),
  })
  .strict();

export const AccountSelectSchema: z.ZodType<Prisma.AccountSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    accountId: z.boolean().optional(),
    providerId: z.boolean().optional(),
    accessToken: z.boolean().optional(),
    refreshToken: z.boolean().optional(),
    accessTokenExpiresAt: z.boolean().optional(),
    refreshTokenExpiresAt: z.boolean().optional(),
    scope: z.boolean().optional(),
    idToken: z.boolean().optional(),
    password: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

// VERIFICATION
//------------------------------------------------------

export const VerificationSelectSchema: z.ZodType<Prisma.VerificationSelect> = z
  .object({
    id: z.boolean().optional(),
    identifier: z.boolean().optional(),
    value: z.boolean().optional(),
    expiresAt: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
  })
  .strict();

// PROFILE
//------------------------------------------------------

export const ProfileIncludeSchema: z.ZodType<Prisma.ProfileInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

export const ProfileArgsSchema: z.ZodType<Prisma.ProfileDefaultArgs> = z
  .object({
    select: z.lazy(() => ProfileSelectSchema).optional(),
    include: z.lazy(() => ProfileIncludeSchema).optional(),
  })
  .strict();

export const ProfileSelectSchema: z.ZodType<Prisma.ProfileSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    address: z.boolean().optional(),
    country: z.boolean().optional(),
    state: z.boolean().optional(),
    city: z.boolean().optional(),
    postalCode: z.boolean().optional(),
    governmentId: z.boolean().optional(),
    governmentIdType: z.boolean().optional(),
    governmentIdExt: z.boolean().optional(),
    kycStatus: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

// BUSINESS PROFILE
//------------------------------------------------------

export const BusinessProfileIncludeSchema: z.ZodType<Prisma.BusinessProfileInclude> =
  z
    .object({
      account: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
    })
    .strict();

export const BusinessProfileArgsSchema: z.ZodType<Prisma.BusinessProfileDefaultArgs> =
  z
    .object({
      select: z.lazy(() => BusinessProfileSelectSchema).optional(),
      include: z.lazy(() => BusinessProfileIncludeSchema).optional(),
    })
    .strict();

export const BusinessProfileSelectSchema: z.ZodType<Prisma.BusinessProfileSelect> =
  z
    .object({
      id: z.boolean().optional(),
      financialAccountId: z.boolean().optional(),
      address: z.boolean().optional(),
      creationMonth: z.boolean().optional(),
      creationYear: z.boolean().optional(),
      proofOfAddress: z.boolean().optional(),
      proofOfAddressExt: z.boolean().optional(),
      certificate: z.boolean().optional(),
      certificateExt: z.boolean().optional(),
      approved: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      account: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
    })
    .strict();

// FINANCIAL ACCOUNT
//------------------------------------------------------

export const FinancialAccountIncludeSchema: z.ZodType<Prisma.FinancialAccountInclude> =
  z
    .object({
      creator: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      businessProfile: z
        .union([z.boolean(), z.lazy(() => BusinessProfileArgsSchema)])
        .optional(),
      accountUsers: z
        .union([z.boolean(), z.lazy(() => AccountUserFindManyArgsSchema)])
        .optional(),
      jointAccountRequests: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountRequestFindManyArgsSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountModRequestFindManyArgsSchema),
        ])
        .optional(),
      notifications: z
        .union([z.boolean(), z.lazy(() => NotificationFindManyArgsSchema)])
        .optional(),
      transactions: z
        .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
        .optional(),
      receivedTransactions: z
        .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
        .optional(),
      investments: z
        .union([z.boolean(), z.lazy(() => InvestmentFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([
          z.boolean(),
          z.lazy(() => FinancialAccountCountOutputTypeArgsSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountArgsSchema: z.ZodType<Prisma.FinancialAccountDefaultArgs> =
  z
    .object({
      select: z.lazy(() => FinancialAccountSelectSchema).optional(),
      include: z.lazy(() => FinancialAccountIncludeSchema).optional(),
    })
    .strict();

export const FinancialAccountCountOutputTypeArgsSchema: z.ZodType<Prisma.FinancialAccountCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z
        .lazy(() => FinancialAccountCountOutputTypeSelectSchema)
        .nullish(),
    })
    .strict();

export const FinancialAccountCountOutputTypeSelectSchema: z.ZodType<Prisma.FinancialAccountCountOutputTypeSelect> =
  z
    .object({
      accountUsers: z.boolean().optional(),
      jointAccountRequests: z.boolean().optional(),
      jointAccountModRequests: z.boolean().optional(),
      notifications: z.boolean().optional(),
      transactions: z.boolean().optional(),
      receivedTransactions: z.boolean().optional(),
      investments: z.boolean().optional(),
    })
    .strict();

export const FinancialAccountSelectSchema: z.ZodType<Prisma.FinancialAccountSelect> =
  z
    .object({
      id: z.boolean().optional(),
      creatorId: z.boolean().optional(),
      name: z.boolean().optional(),
      number: z.boolean().optional(),
      status: z.boolean().optional(),
      type: z.boolean().optional(),
      ownership: z.boolean().optional(),
      balance: z.boolean().optional(),
      totalTransactions: z.boolean().optional(),
      totalInvestments: z.boolean().optional(),
      firstTransactionAt: z.boolean().optional(),
      lastTransactionAt: z.boolean().optional(),
      closedAt: z.boolean().optional(),
      dormantAt: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      creator: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      businessProfile: z
        .union([z.boolean(), z.lazy(() => BusinessProfileArgsSchema)])
        .optional(),
      accountUsers: z
        .union([z.boolean(), z.lazy(() => AccountUserFindManyArgsSchema)])
        .optional(),
      jointAccountRequests: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountRequestFindManyArgsSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountModRequestFindManyArgsSchema),
        ])
        .optional(),
      notifications: z
        .union([z.boolean(), z.lazy(() => NotificationFindManyArgsSchema)])
        .optional(),
      transactions: z
        .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
        .optional(),
      receivedTransactions: z
        .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
        .optional(),
      investments: z
        .union([z.boolean(), z.lazy(() => InvestmentFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([
          z.boolean(),
          z.lazy(() => FinancialAccountCountOutputTypeArgsSchema),
        ])
        .optional(),
    })
    .strict();

// ACCOUNT USER
//------------------------------------------------------

export const AccountUserIncludeSchema: z.ZodType<Prisma.AccountUserInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    transactions: z
      .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
      .optional(),
    investments: z
      .union([z.boolean(), z.lazy(() => InvestmentFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => AccountUserCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const AccountUserArgsSchema: z.ZodType<Prisma.AccountUserDefaultArgs> = z
  .object({
    select: z.lazy(() => AccountUserSelectSchema).optional(),
    include: z.lazy(() => AccountUserIncludeSchema).optional(),
  })
  .strict();

export const AccountUserCountOutputTypeArgsSchema: z.ZodType<Prisma.AccountUserCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => AccountUserCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const AccountUserCountOutputTypeSelectSchema: z.ZodType<Prisma.AccountUserCountOutputTypeSelect> =
  z
    .object({
      transactions: z.boolean().optional(),
      investments: z.boolean().optional(),
    })
    .strict();

export const AccountUserSelectSchema: z.ZodType<Prisma.AccountUserSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    financialAccountId: z.boolean().optional(),
    role: z.boolean().optional(),
    ownership: z.boolean().optional(),
    autosign: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    transactions: z
      .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
      .optional(),
    investments: z
      .union([z.boolean(), z.lazy(() => InvestmentFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => AccountUserCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// JOINT ACCOUNT REQUEST
//------------------------------------------------------

export const JointAccountRequestIncludeSchema: z.ZodType<Prisma.JointAccountRequestInclude> =
  z
    .object({
      creator: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      recipient: z
        .union([z.boolean(), z.lazy(() => UserArgsSchema)])
        .optional(),
      financialAccount: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
    })
    .strict();

export const JointAccountRequestArgsSchema: z.ZodType<Prisma.JointAccountRequestDefaultArgs> =
  z
    .object({
      select: z.lazy(() => JointAccountRequestSelectSchema).optional(),
      include: z.lazy(() => JointAccountRequestIncludeSchema).optional(),
    })
    .strict();

export const JointAccountRequestSelectSchema: z.ZodType<Prisma.JointAccountRequestSelect> =
  z
    .object({
      id: z.boolean().optional(),
      creatorId: z.boolean().optional(),
      recipientName: z.boolean().optional(),
      recipientEmail: z.boolean().optional(),
      role: z.boolean().optional(),
      ownership: z.boolean().optional(),
      recipientId: z.boolean().optional(),
      financialAccountId: z.boolean().optional(),
      description: z.boolean().optional(),
      lastReminderAt: z.boolean().optional(),
      reminderCount: z.boolean().optional(),
      status: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      creator: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      recipient: z
        .union([z.boolean(), z.lazy(() => UserArgsSchema)])
        .optional(),
      financialAccount: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
    })
    .strict();

// JOINT ACCOUNT MOD REQUEST
//------------------------------------------------------

export const JointAccountModRequestIncludeSchema: z.ZodType<Prisma.JointAccountModRequestInclude> =
  z
    .object({
      creator: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      account: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
      transaction: z
        .union([z.boolean(), z.lazy(() => TransactionArgsSchema)])
        .optional(),
      approvals: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountModRequestApprovalFindManyArgsSchema),
        ])
        .optional(),
      _count: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountModRequestCountOutputTypeArgsSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestArgsSchema: z.ZodType<Prisma.JointAccountModRequestDefaultArgs> =
  z
    .object({
      select: z.lazy(() => JointAccountModRequestSelectSchema).optional(),
      include: z.lazy(() => JointAccountModRequestIncludeSchema).optional(),
    })
    .strict();

export const JointAccountModRequestCountOutputTypeArgsSchema: z.ZodType<Prisma.JointAccountModRequestCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z
        .lazy(() => JointAccountModRequestCountOutputTypeSelectSchema)
        .nullish(),
    })
    .strict();

export const JointAccountModRequestCountOutputTypeSelectSchema: z.ZodType<Prisma.JointAccountModRequestCountOutputTypeSelect> =
  z
    .object({
      approvals: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestSelectSchema: z.ZodType<Prisma.JointAccountModRequestSelect> =
  z
    .object({
      id: z.boolean().optional(),
      creatorId: z.boolean().optional(),
      financialAccountId: z.boolean().optional(),
      type: z.boolean().optional(),
      transactionId: z.boolean().optional(),
      description: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      creator: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      account: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
      transaction: z
        .union([z.boolean(), z.lazy(() => TransactionArgsSchema)])
        .optional(),
      approvals: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountModRequestApprovalFindManyArgsSchema),
        ])
        .optional(),
      _count: z
        .union([
          z.boolean(),
          z.lazy(() => JointAccountModRequestCountOutputTypeArgsSchema),
        ])
        .optional(),
    })
    .strict();

// JOINT ACCOUNT MOD REQUEST APPROVAL
//------------------------------------------------------

export const JointAccountModRequestApprovalIncludeSchema: z.ZodType<Prisma.JointAccountModRequestApprovalInclude> =
  z
    .object({
      request: z
        .union([z.boolean(), z.lazy(() => JointAccountModRequestArgsSchema)])
        .optional(),
      approver: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalDefaultArgs> =
  z
    .object({
      select: z
        .lazy(() => JointAccountModRequestApprovalSelectSchema)
        .optional(),
      include: z
        .lazy(() => JointAccountModRequestApprovalIncludeSchema)
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalSelectSchema: z.ZodType<Prisma.JointAccountModRequestApprovalSelect> =
  z
    .object({
      id: z.boolean().optional(),
      jointAccountModRequestId: z.boolean().optional(),
      approverId: z.boolean().optional(),
      status: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      request: z
        .union([z.boolean(), z.lazy(() => JointAccountModRequestArgsSchema)])
        .optional(),
      approver: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

// INVESTMENT PLAN
//------------------------------------------------------

export const InvestmentPlanSelectSchema: z.ZodType<Prisma.InvestmentPlanSelect> =
  z
    .object({
      id: z.boolean().optional(),
      name: z.boolean().optional(),
      category: z.boolean().optional(),
      minimumDeposit: z.boolean().optional(),
      maximumDeposit: z.boolean().optional(),
      duration: z.boolean().optional(),
      profitDistribution: z.boolean().optional(),
      percentageTotalReturn: z.boolean().optional(),
      percentagePeriodicReturn: z.boolean().optional(),
      terminationFee: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
    })
    .strict();

// INVESTMENT
//------------------------------------------------------

export const InvestmentIncludeSchema: z.ZodType<Prisma.InvestmentInclude> = z
  .object({
    investor: z
      .union([z.boolean(), z.lazy(() => AccountUserArgsSchema)])
      .optional(),
    transactions: z
      .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
      .optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => InvestmentCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const InvestmentArgsSchema: z.ZodType<Prisma.InvestmentDefaultArgs> = z
  .object({
    select: z.lazy(() => InvestmentSelectSchema).optional(),
    include: z.lazy(() => InvestmentIncludeSchema).optional(),
  })
  .strict();

export const InvestmentCountOutputTypeArgsSchema: z.ZodType<Prisma.InvestmentCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => InvestmentCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const InvestmentCountOutputTypeSelectSchema: z.ZodType<Prisma.InvestmentCountOutputTypeSelect> =
  z
    .object({
      transactions: z.boolean().optional(),
    })
    .strict();

export const InvestmentSelectSchema: z.ZodType<Prisma.InvestmentSelect> = z
  .object({
    id: z.boolean().optional(),
    financialAccountId: z.boolean().optional(),
    investorId: z.boolean().optional(),
    deposit: z.boolean().optional(),
    investmentName: z.boolean().optional(),
    totalProfit: z.boolean().optional(),
    profitCount: z.boolean().optional(),
    status: z.boolean().optional(),
    pausedAt: z.boolean().optional(),
    pausedReason: z.boolean().optional(),
    closedAt: z.boolean().optional(),
    closedReason: z.boolean().optional(),
    terminatedAt: z.boolean().optional(),
    terminatedReason: z.boolean().optional(),
    category: z.boolean().optional(),
    daysCompleted: z.boolean().optional(),
    duration: z.boolean().optional(),
    totalReturn: z.boolean().optional(),
    periodicReturn: z.boolean().optional(),
    profitDistribution: z.boolean().optional(),
    terminationFee: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    investor: z
      .union([z.boolean(), z.lazy(() => AccountUserArgsSchema)])
      .optional(),
    transactions: z
      .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
      .optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => InvestmentCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// TRANSACTION
//------------------------------------------------------

export const TransactionIncludeSchema: z.ZodType<Prisma.TransactionInclude> = z
  .object({
    initiator: z
      .union([z.boolean(), z.lazy(() => AccountUserArgsSchema)])
      .optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    recipientAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    investment: z
      .union([z.boolean(), z.lazy(() => InvestmentArgsSchema)])
      .optional(),
    jointAccountModRequests: z
      .union([
        z.boolean(),
        z.lazy(() => JointAccountModRequestFindManyArgsSchema),
      ])
      .optional(),
    parentTransaction: z
      .union([z.boolean(), z.lazy(() => TransactionArgsSchema)])
      .optional(),
    childTransactions: z
      .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => TransactionCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const TransactionArgsSchema: z.ZodType<Prisma.TransactionDefaultArgs> = z
  .object({
    select: z.lazy(() => TransactionSelectSchema).optional(),
    include: z.lazy(() => TransactionIncludeSchema).optional(),
  })
  .strict();

export const TransactionCountOutputTypeArgsSchema: z.ZodType<Prisma.TransactionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => TransactionCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const TransactionCountOutputTypeSelectSchema: z.ZodType<Prisma.TransactionCountOutputTypeSelect> =
  z
    .object({
      jointAccountModRequests: z.boolean().optional(),
      childTransactions: z.boolean().optional(),
    })
    .strict();

export const TransactionSelectSchema: z.ZodType<Prisma.TransactionSelect> = z
  .object({
    id: z.boolean().optional(),
    amount: z.boolean().optional(),
    currency: z.boolean().optional(),
    USDAmount: z.boolean().optional(),
    rate: z.boolean().optional(),
    charges: z.boolean().optional(),
    financialAccountId: z.boolean().optional(),
    type: z.boolean().optional(),
    initiatorAccountId: z.boolean().optional(),
    recipientAccountId: z.boolean().optional(),
    investmentId: z.boolean().optional(),
    status: z.boolean().optional(),
    parentTransactionId: z.boolean().optional(),
    approvedAt: z.boolean().optional(),
    failedAt: z.boolean().optional(),
    failReason: z.boolean().optional(),
    depositWalletAddress: z.boolean().optional(),
    depositWalletAddressNetwork: z.boolean().optional(),
    withdrawalWalletAddress: z.boolean().optional(),
    withdrawalWalletAddressNetwork: z.boolean().optional(),
    bank: z.boolean().optional(),
    bankAccount: z.boolean().optional(),
    description: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    initiator: z
      .union([z.boolean(), z.lazy(() => AccountUserArgsSchema)])
      .optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    recipientAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
    investment: z
      .union([z.boolean(), z.lazy(() => InvestmentArgsSchema)])
      .optional(),
    jointAccountModRequests: z
      .union([
        z.boolean(),
        z.lazy(() => JointAccountModRequestFindManyArgsSchema),
      ])
      .optional(),
    parentTransaction: z
      .union([z.boolean(), z.lazy(() => TransactionArgsSchema)])
      .optional(),
    childTransactions: z
      .union([z.boolean(), z.lazy(() => TransactionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => TransactionCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// NOTIFICATION
//------------------------------------------------------

export const NotificationIncludeSchema: z.ZodType<Prisma.NotificationInclude> =
  z
    .object({
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      financialAccount: z
        .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
        .optional(),
    })
    .strict();

export const NotificationArgsSchema: z.ZodType<Prisma.NotificationDefaultArgs> =
  z
    .object({
      select: z.lazy(() => NotificationSelectSchema).optional(),
      include: z.lazy(() => NotificationIncludeSchema).optional(),
    })
    .strict();

export const NotificationSelectSchema: z.ZodType<Prisma.NotificationSelect> = z
  .object({
    id: z.boolean().optional(),
    title: z.boolean().optional(),
    body: z.boolean().optional(),
    bodyType: z.boolean().optional(),
    userId: z.boolean().optional(),
    financialAccountId: z.boolean().optional(),
    link: z.boolean().optional(),
    isRead: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    financialAccount: z
      .union([z.boolean(), z.lazy(() => FinancialAccountArgsSchema)])
      .optional(),
  })
  .strict();

// CURRENCY
//------------------------------------------------------

export const CurrencySelectSchema: z.ZodType<Prisma.CurrencySelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    symbol: z.boolean().optional(),
    image: z.boolean().optional(),
    rate: z.boolean().optional(),
    rateUpdatedAt: z.boolean().optional(),
    walletAddress: z.boolean().optional(),
    walletAddressNetwork: z.boolean().optional(),
    allowWithdrawal: z.boolean().optional(),
    withdrawalCharge: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
  })
  .strict();

// SETTINGS
//------------------------------------------------------

export const SettingsSelectSchema: z.ZodType<Prisma.SettingsSelect> = z
  .object({
    id: z.boolean().optional(),
    allowWithdrawals: z.boolean().optional(),
  })
  .strict();

/////////////////////////////////////////
// INPUT TYPES
/////////////////////////////////////////

export const UserWhereInputSchema: z.ZodType<Prisma.UserWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => UserWhereInputSchema),
        z.lazy(() => UserWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => UserWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => UserWhereInputSchema),
        z.lazy(() => UserWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    emailVerified: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    image: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    role: z
      .union([
        z.lazy(() => EnumUserRoleFilterSchema),
        z.lazy(() => UserRoleSchema),
      ])
      .optional(),
    banned: z
      .union([z.lazy(() => BoolNullableFilterSchema), z.boolean()])
      .optional()
      .nullable(),
    banReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    banExpires: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    profile: z
      .union([
        z.lazy(() => ProfileNullableScalarRelationFilterSchema),
        z.lazy(() => ProfileWhereInputSchema),
      ])
      .optional()
      .nullable(),
    sessions: z.lazy(() => SessionListRelationFilterSchema).optional(),
    accounts: z.lazy(() => AccountListRelationFilterSchema).optional(),
    createdAccounts: z
      .lazy(() => FinancialAccountListRelationFilterSchema)
      .optional(),
    accountMemberships: z
      .lazy(() => AccountUserListRelationFilterSchema)
      .optional(),
    createdJointAccountRequests: z
      .lazy(() => JointAccountRequestListRelationFilterSchema)
      .optional(),
    receivedJointAccountRequests: z
      .lazy(() => JointAccountRequestListRelationFilterSchema)
      .optional(),
    createdJointAccountModRequests: z
      .lazy(() => JointAccountModRequestListRelationFilterSchema)
      .optional(),
    notifications: z
      .lazy(() => NotificationListRelationFilterSchema)
      .optional(),
    approvedJointAccountModRequests: z
      .lazy(() => JointAccountModRequestApprovalListRelationFilterSchema)
      .optional(),
  })
  .strict();

export const UserOrderByWithRelationInputSchema: z.ZodType<Prisma.UserOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      banned: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      banReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      banExpires: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      profile: z.lazy(() => ProfileOrderByWithRelationInputSchema).optional(),
      sessions: z
        .lazy(() => SessionOrderByRelationAggregateInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountOrderByRelationAggregateInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountOrderByRelationAggregateInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserOrderByRelationAggregateInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(() => JointAccountRequestOrderByRelationAggregateInputSchema)
        .optional(),
      receivedJointAccountRequests: z
        .lazy(() => JointAccountRequestOrderByRelationAggregateInputSchema)
        .optional(),
      createdJointAccountModRequests: z
        .lazy(() => JointAccountModRequestOrderByRelationAggregateInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationOrderByRelationAggregateInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalOrderByRelationAggregateInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserWhereUniqueInputSchema: z.ZodType<Prisma.UserWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        email: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        email: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          email: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => UserWhereInputSchema),
              z.lazy(() => UserWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => UserWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => UserWhereInputSchema),
              z.lazy(() => UserWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          emailVerified: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          image: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          role: z
            .union([
              z.lazy(() => EnumUserRoleFilterSchema),
              z.lazy(() => UserRoleSchema),
            ])
            .optional(),
          banned: z
            .union([z.lazy(() => BoolNullableFilterSchema), z.boolean()])
            .optional()
            .nullable(),
          banReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          banExpires: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          profile: z
            .union([
              z.lazy(() => ProfileNullableScalarRelationFilterSchema),
              z.lazy(() => ProfileWhereInputSchema),
            ])
            .optional()
            .nullable(),
          sessions: z.lazy(() => SessionListRelationFilterSchema).optional(),
          accounts: z.lazy(() => AccountListRelationFilterSchema).optional(),
          createdAccounts: z
            .lazy(() => FinancialAccountListRelationFilterSchema)
            .optional(),
          accountMemberships: z
            .lazy(() => AccountUserListRelationFilterSchema)
            .optional(),
          createdJointAccountRequests: z
            .lazy(() => JointAccountRequestListRelationFilterSchema)
            .optional(),
          receivedJointAccountRequests: z
            .lazy(() => JointAccountRequestListRelationFilterSchema)
            .optional(),
          createdJointAccountModRequests: z
            .lazy(() => JointAccountModRequestListRelationFilterSchema)
            .optional(),
          notifications: z
            .lazy(() => NotificationListRelationFilterSchema)
            .optional(),
          approvedJointAccountModRequests: z
            .lazy(() => JointAccountModRequestApprovalListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    );

export const UserOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      banned: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      banReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      banExpires: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => UserCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => UserMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => UserMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const UserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UserScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      emailVerified: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      image: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => EnumUserRoleWithAggregatesFilterSchema),
          z.lazy(() => UserRoleSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.lazy(() => BoolNullableWithAggregatesFilterSchema),
          z.boolean(),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const SessionWhereInputSchema: z.ZodType<Prisma.SessionWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SessionWhereInputSchema),
        z.lazy(() => SessionWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => SessionWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SessionWhereInputSchema),
        z.lazy(() => SessionWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    token: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    expiresAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    ipAddress: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    userAgent: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    impersonatedBy: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema),
      ])
      .optional(),
  })
  .strict();

export const SessionOrderByWithRelationInputSchema: z.ZodType<Prisma.SessionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      userAgent: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      impersonatedBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const SessionWhereUniqueInputSchema: z.ZodType<Prisma.SessionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        token: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        token: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          token: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => SessionWhereInputSchema),
              z.lazy(() => SessionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => SessionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SessionWhereInputSchema),
              z.lazy(() => SessionWhereInputSchema).array(),
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          expiresAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          ipAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          userAgent: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          impersonatedBy: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const SessionOrderByWithAggregationInputSchema: z.ZodType<Prisma.SessionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      userAgent: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      impersonatedBy: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => SessionCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SessionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SessionMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const SessionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SessionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => SessionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SessionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      token: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expiresAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const AccountWhereInputSchema: z.ZodType<Prisma.AccountWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => AccountWhereInputSchema),
        z.lazy(() => AccountWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => AccountWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => AccountWhereInputSchema),
        z.lazy(() => AccountWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    accountId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    providerId: z
      .union([z.lazy(() => StringFilterSchema), z.string()])
      .optional(),
    accessToken: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    refreshToken: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    accessTokenExpiresAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    refreshTokenExpiresAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    scope: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    idToken: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    password: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema),
      ])
      .optional(),
  })
  .strict();

export const AccountOrderByWithRelationInputSchema: z.ZodType<Prisma.AccountOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      accountId: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      refreshToken: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      accessTokenExpiresAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      refreshTokenExpiresAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      scope: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      idToken: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const AccountWhereUniqueInputSchema: z.ZodType<Prisma.AccountWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => AccountWhereInputSchema),
              z.lazy(() => AccountWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => AccountWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => AccountWhereInputSchema),
              z.lazy(() => AccountWhereInputSchema).array(),
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          accountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          providerId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          accessToken: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          refreshToken: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          accessTokenExpiresAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          refreshTokenExpiresAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          scope: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          idToken: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          password: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const AccountOrderByWithAggregationInputSchema: z.ZodType<Prisma.AccountOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      accountId: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      refreshToken: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      accessTokenExpiresAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      refreshTokenExpiresAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      scope: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      idToken: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      password: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => AccountCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => AccountMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => AccountMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const AccountScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AccountScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AccountScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      accountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      providerId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      accessToken: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const VerificationWhereInputSchema: z.ZodType<Prisma.VerificationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => VerificationWhereInputSchema),
          z.lazy(() => VerificationWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => VerificationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => VerificationWhereInputSchema),
          z.lazy(() => VerificationWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      identifier: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      value: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const VerificationOrderByWithRelationInputSchema: z.ZodType<Prisma.VerificationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const VerificationWhereUniqueInputSchema: z.ZodType<Prisma.VerificationWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => VerificationWhereInputSchema),
              z.lazy(() => VerificationWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => VerificationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => VerificationWhereInputSchema),
              z.lazy(() => VerificationWhereInputSchema).array(),
            ])
            .optional(),
          identifier: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          value: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          expiresAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
        })
        .strict(),
    );

export const VerificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.VerificationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => VerificationCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => VerificationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => VerificationMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const VerificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.VerificationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => VerificationScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => VerificationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => VerificationScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => VerificationScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      identifier: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      value: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expiresAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const ProfileWhereInputSchema: z.ZodType<Prisma.ProfileWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ProfileWhereInputSchema),
        z.lazy(() => ProfileWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => ProfileWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ProfileWhereInputSchema),
        z.lazy(() => ProfileWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    address: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    country: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    state: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    city: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    postalCode: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    governmentId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    governmentIdType: z
      .union([
        z.lazy(() => EnumGovernmentIdTypeNullableFilterSchema),
        z.lazy(() => GovernmentIdTypeSchema),
      ])
      .optional()
      .nullable(),
    governmentIdExt: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    kycStatus: z
      .union([
        z.lazy(() => EnumKycStatusNullableFilterSchema),
        z.lazy(() => KycStatusSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    user: z
      .union([
        z.lazy(() => UserScalarRelationFilterSchema),
        z.lazy(() => UserWhereInputSchema),
      ])
      .optional(),
  })
  .strict();

export const ProfileOrderByWithRelationInputSchema: z.ZodType<Prisma.ProfileOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      address: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      country: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      state: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      postalCode: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      governmentId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      governmentIdType: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      governmentIdExt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      kycStatus: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const ProfileWhereUniqueInputSchema: z.ZodType<Prisma.ProfileWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        userId: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        userId: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          userId: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ProfileWhereInputSchema),
              z.lazy(() => ProfileWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ProfileWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ProfileWhereInputSchema),
              z.lazy(() => ProfileWhereInputSchema).array(),
            ])
            .optional(),
          address: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          country: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          state: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          city: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          postalCode: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          governmentId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          governmentIdType: z
            .union([
              z.lazy(() => EnumGovernmentIdTypeNullableFilterSchema),
              z.lazy(() => GovernmentIdTypeSchema),
            ])
            .optional()
            .nullable(),
          governmentIdExt: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          kycStatus: z
            .union([
              z.lazy(() => EnumKycStatusNullableFilterSchema),
              z.lazy(() => KycStatusSchema),
            ])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const ProfileOrderByWithAggregationInputSchema: z.ZodType<Prisma.ProfileOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      address: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      country: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      state: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      city: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      postalCode: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      governmentId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      governmentIdType: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      governmentIdExt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      kycStatus: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ProfileCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ProfileMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ProfileMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const ProfileScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ProfileScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ProfileScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ProfileScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      address: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      state: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      postalCode: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      governmentId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      governmentIdType: z
        .union([
          z.lazy(() => EnumGovernmentIdTypeNullableWithAggregatesFilterSchema),
          z.lazy(() => GovernmentIdTypeSchema),
        ])
        .optional()
        .nullable(),
      governmentIdExt: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      kycStatus: z
        .union([
          z.lazy(() => EnumKycStatusNullableWithAggregatesFilterSchema),
          z.lazy(() => KycStatusSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileWhereInputSchema: z.ZodType<Prisma.BusinessProfileWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => BusinessProfileWhereInputSchema),
          z.lazy(() => BusinessProfileWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => BusinessProfileWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => BusinessProfileWhereInputSchema),
          z.lazy(() => BusinessProfileWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      address: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      creationMonth: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      creationYear: z
        .union([z.lazy(() => IntNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      certificate: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      certificateExt: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      approved: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      account: z
        .union([
          z.lazy(() => FinancialAccountScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileOrderByWithRelationInputSchema: z.ZodType<Prisma.BusinessProfileOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      address: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      creationMonth: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      creationYear: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      proofOfAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      proofOfAddressExt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      certificate: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      certificateExt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      approved: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      account: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict();

export const BusinessProfileWhereUniqueInputSchema: z.ZodType<Prisma.BusinessProfileWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        financialAccountId: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        financialAccountId: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          financialAccountId: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => BusinessProfileWhereInputSchema),
              z.lazy(() => BusinessProfileWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => BusinessProfileWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => BusinessProfileWhereInputSchema),
              z.lazy(() => BusinessProfileWhereInputSchema).array(),
            ])
            .optional(),
          address: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          creationMonth: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          creationYear: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          proofOfAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          proofOfAddressExt: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          certificate: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          certificateExt: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          approved: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          account: z
            .union([
              z.lazy(() => FinancialAccountScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const BusinessProfileOrderByWithAggregationInputSchema: z.ZodType<Prisma.BusinessProfileOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      address: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      creationMonth: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      creationYear: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      proofOfAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      proofOfAddressExt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      certificate: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      certificateExt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      approved: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => BusinessProfileCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => BusinessProfileAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => BusinessProfileMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => BusinessProfileMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => BusinessProfileSumOrderByAggregateInputSchema)
        .optional(),
    })
    .strict();

export const BusinessProfileScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.BusinessProfileScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => BusinessProfileScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => BusinessProfileScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => BusinessProfileScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => BusinessProfileScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => BusinessProfileScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      address: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.lazy(() => IntNullableWithAggregatesFilterSchema),
          z.number(),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountWhereInputSchema: z.ZodType<Prisma.FinancialAccountWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FinancialAccountWhereInputSchema),
          z.lazy(() => FinancialAccountWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => FinancialAccountWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FinancialAccountWhereInputSchema),
          z.lazy(() => FinancialAccountWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      creatorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      number: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumAccountStatusFilterSchema),
          z.lazy(() => AccountStatusSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumAccountTypeFilterSchema),
          z.lazy(() => AccountTypeSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => EnumAccountOwnershipFilterSchema),
          z.lazy(() => AccountOwnershipSchema),
        ])
        .optional(),
      balance: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      totalTransactions: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      totalInvestments: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      firstTransactionAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      closedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      dormantAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      creator: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional(),
      businessProfile: z
        .union([
          z.lazy(() => BusinessProfileNullableScalarRelationFilterSchema),
          z.lazy(() => BusinessProfileWhereInputSchema),
        ])
        .optional()
        .nullable(),
      accountUsers: z
        .lazy(() => AccountUserListRelationFilterSchema)
        .optional(),
      jointAccountRequests: z
        .lazy(() => JointAccountRequestListRelationFilterSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(() => JointAccountModRequestListRelationFilterSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationListRelationFilterSchema)
        .optional(),
      transactions: z
        .lazy(() => TransactionListRelationFilterSchema)
        .optional(),
      receivedTransactions: z
        .lazy(() => TransactionListRelationFilterSchema)
        .optional(),
      investments: z.lazy(() => InvestmentListRelationFilterSchema).optional(),
    })
    .strict();

export const FinancialAccountOrderByWithRelationInputSchema: z.ZodType<Prisma.FinancialAccountOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      number: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
      firstTransactionAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      lastTransactionAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      closedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      dormantAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      creator: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      businessProfile: z
        .lazy(() => BusinessProfileOrderByWithRelationInputSchema)
        .optional(),
      accountUsers: z
        .lazy(() => AccountUserOrderByRelationAggregateInputSchema)
        .optional(),
      jointAccountRequests: z
        .lazy(() => JointAccountRequestOrderByRelationAggregateInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(() => JointAccountModRequestOrderByRelationAggregateInputSchema)
        .optional(),
      notifications: z
        .lazy(() => NotificationOrderByRelationAggregateInputSchema)
        .optional(),
      transactions: z
        .lazy(() => TransactionOrderByRelationAggregateInputSchema)
        .optional(),
      receivedTransactions: z
        .lazy(() => TransactionOrderByRelationAggregateInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const FinancialAccountWhereUniqueInputSchema: z.ZodType<Prisma.FinancialAccountWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => FinancialAccountWhereInputSchema),
              z.lazy(() => FinancialAccountWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => FinancialAccountWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => FinancialAccountWhereInputSchema),
              z.lazy(() => FinancialAccountWhereInputSchema).array(),
            ])
            .optional(),
          creatorId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          number: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumAccountStatusFilterSchema),
              z.lazy(() => AccountStatusSchema),
            ])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumAccountTypeFilterSchema),
              z.lazy(() => AccountTypeSchema),
            ])
            .optional(),
          ownership: z
            .union([
              z.lazy(() => EnumAccountOwnershipFilterSchema),
              z.lazy(() => AccountOwnershipSchema),
            ])
            .optional(),
          balance: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          totalTransactions: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          totalInvestments: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          firstTransactionAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          lastTransactionAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          closedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          dormantAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          creator: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          businessProfile: z
            .union([
              z.lazy(() => BusinessProfileNullableScalarRelationFilterSchema),
              z.lazy(() => BusinessProfileWhereInputSchema),
            ])
            .optional()
            .nullable(),
          accountUsers: z
            .lazy(() => AccountUserListRelationFilterSchema)
            .optional(),
          jointAccountRequests: z
            .lazy(() => JointAccountRequestListRelationFilterSchema)
            .optional(),
          jointAccountModRequests: z
            .lazy(() => JointAccountModRequestListRelationFilterSchema)
            .optional(),
          notifications: z
            .lazy(() => NotificationListRelationFilterSchema)
            .optional(),
          transactions: z
            .lazy(() => TransactionListRelationFilterSchema)
            .optional(),
          receivedTransactions: z
            .lazy(() => TransactionListRelationFilterSchema)
            .optional(),
          investments: z
            .lazy(() => InvestmentListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    );

export const FinancialAccountOrderByWithAggregationInputSchema: z.ZodType<Prisma.FinancialAccountOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      number: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
      firstTransactionAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      lastTransactionAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      closedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      dormantAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => FinancialAccountCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => FinancialAccountAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => FinancialAccountMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => FinancialAccountMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => FinancialAccountSumOrderByAggregateInputSchema)
        .optional(),
    })
    .strict();

export const FinancialAccountScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.FinancialAccountScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FinancialAccountScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => FinancialAccountScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => FinancialAccountScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FinancialAccountScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => FinancialAccountScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      creatorId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      number: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumAccountStatusWithAggregatesFilterSchema),
          z.lazy(() => AccountStatusSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumAccountTypeWithAggregatesFilterSchema),
          z.lazy(() => AccountTypeSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => EnumAccountOwnershipWithAggregatesFilterSchema),
          z.lazy(() => AccountOwnershipSchema),
        ])
        .optional(),
      balance: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      totalTransactions: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      totalInvestments: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      firstTransactionAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserWhereInputSchema: z.ZodType<Prisma.AccountUserWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountUserWhereInputSchema),
          z.lazy(() => AccountUserWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AccountUserWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountUserWhereInputSchema),
          z.lazy(() => AccountUserWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumAccountUserRoleFilterSchema),
          z.lazy(() => AccountUserRoleSchema),
        ])
        .optional(),
      ownership: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      autosign: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      user: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional(),
      financialAccount: z
        .union([
          z.lazy(() => FinancialAccountScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(() => TransactionListRelationFilterSchema)
        .optional(),
      investments: z.lazy(() => InvestmentListRelationFilterSchema).optional(),
    })
    .strict();

export const AccountUserOrderByWithRelationInputSchema: z.ZodType<Prisma.AccountUserOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      autosign: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      financialAccount: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
      transactions: z
        .lazy(() => TransactionOrderByRelationAggregateInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserWhereUniqueInputSchema: z.ZodType<Prisma.AccountUserWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        userId_financialAccountId: z.lazy(
          () => AccountUserUserIdFinancialAccountIdCompoundUniqueInputSchema,
        ),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        userId_financialAccountId: z.lazy(
          () => AccountUserUserIdFinancialAccountIdCompoundUniqueInputSchema,
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          userId_financialAccountId: z
            .lazy(
              () =>
                AccountUserUserIdFinancialAccountIdCompoundUniqueInputSchema,
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => AccountUserWhereInputSchema),
              z.lazy(() => AccountUserWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => AccountUserWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => AccountUserWhereInputSchema),
              z.lazy(() => AccountUserWhereInputSchema).array(),
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          financialAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          role: z
            .union([
              z.lazy(() => EnumAccountUserRoleFilterSchema),
              z.lazy(() => AccountUserRoleSchema),
            ])
            .optional(),
          ownership: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          autosign: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          financialAccount: z
            .union([
              z.lazy(() => FinancialAccountScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional(),
          transactions: z
            .lazy(() => TransactionListRelationFilterSchema)
            .optional(),
          investments: z
            .lazy(() => InvestmentListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    );

export const AccountUserOrderByWithAggregationInputSchema: z.ZodType<Prisma.AccountUserOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      autosign: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => AccountUserCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => AccountUserAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => AccountUserMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => AccountUserMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => AccountUserSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const AccountUserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AccountUserScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountUserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountUserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AccountUserScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountUserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountUserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumAccountUserRoleWithAggregatesFilterSchema),
          z.lazy(() => AccountUserRoleSchema),
        ])
        .optional(),
      ownership: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      autosign: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestWhereInputSchema: z.ZodType<Prisma.JointAccountRequestWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountRequestWhereInputSchema),
          z.lazy(() => JointAccountRequestWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountRequestWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountRequestWhereInputSchema),
          z.lazy(() => JointAccountRequestWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      creatorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      recipientName: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      recipientEmail: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumAccountUserRoleFilterSchema),
          z.lazy(() => AccountUserRoleSchema),
        ])
        .optional(),
      ownership: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      recipientId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      reminderCount: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumJointAccountRequestStatusFilterSchema),
          z.lazy(() => JointAccountRequestStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      creator: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional(),
      recipient: z
        .union([
          z.lazy(() => UserNullableScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccount: z
        .union([
          z.lazy(() => FinancialAccountScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestOrderByWithRelationInputSchema: z.ZodType<Prisma.JointAccountRequestOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      recipientName: z.lazy(() => SortOrderSchema).optional(),
      recipientEmail: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      recipientId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      lastReminderAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      creator: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      recipient: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      financialAccount: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict();

export const JointAccountRequestWhereUniqueInputSchema: z.ZodType<Prisma.JointAccountRequestWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => JointAccountRequestWhereInputSchema),
              z.lazy(() => JointAccountRequestWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => JointAccountRequestWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => JointAccountRequestWhereInputSchema),
              z.lazy(() => JointAccountRequestWhereInputSchema).array(),
            ])
            .optional(),
          creatorId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          recipientName: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          recipientEmail: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          role: z
            .union([
              z.lazy(() => EnumAccountUserRoleFilterSchema),
              z.lazy(() => AccountUserRoleSchema),
            ])
            .optional(),
          ownership: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          recipientId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          financialAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          lastReminderAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          reminderCount: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumJointAccountRequestStatusFilterSchema),
              z.lazy(() => JointAccountRequestStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          creator: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          recipient: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional()
            .nullable(),
          financialAccount: z
            .union([
              z.lazy(() => FinancialAccountScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const JointAccountRequestOrderByWithAggregationInputSchema: z.ZodType<Prisma.JointAccountRequestOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      recipientName: z.lazy(() => SortOrderSchema).optional(),
      recipientEmail: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      recipientId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      lastReminderAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => JointAccountRequestCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => JointAccountRequestAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => JointAccountRequestMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => JointAccountRequestMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => JointAccountRequestSumOrderByAggregateInputSchema)
        .optional(),
    })
    .strict();

export const JointAccountRequestScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.JointAccountRequestScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => JointAccountRequestScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountRequestScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => JointAccountRequestScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      creatorId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      recipientName: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      recipientEmail: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumAccountUserRoleWithAggregatesFilterSchema),
          z.lazy(() => AccountUserRoleSchema),
        ])
        .optional(),
      ownership: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      recipientId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumJointAccountRequestStatusWithAggregatesFilterSchema),
          z.lazy(() => JointAccountRequestStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestWhereInputSchema: z.ZodType<Prisma.JointAccountModRequestWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountModRequestWhereInputSchema),
          z.lazy(() => JointAccountModRequestWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountModRequestWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountModRequestWhereInputSchema),
          z.lazy(() => JointAccountModRequestWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      creatorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumJointAccountModRequestTypeFilterSchema),
          z.lazy(() => JointAccountModRequestTypeSchema),
        ])
        .optional(),
      transactionId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      creator: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional(),
      account: z
        .union([
          z.lazy(() => FinancialAccountScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional(),
      transaction: z
        .union([
          z.lazy(() => TransactionNullableScalarRelationFilterSchema),
          z.lazy(() => TransactionWhereInputSchema),
        ])
        .optional()
        .nullable(),
      approvals: z
        .lazy(() => JointAccountModRequestApprovalListRelationFilterSchema)
        .optional(),
    })
    .strict();

export const JointAccountModRequestOrderByWithRelationInputSchema: z.ZodType<Prisma.JointAccountModRequestOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      transactionId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      creator: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      account: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
      transaction: z
        .lazy(() => TransactionOrderByWithRelationInputSchema)
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalOrderByRelationAggregateInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestWhereUniqueInputSchema: z.ZodType<Prisma.JointAccountModRequestWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => JointAccountModRequestWhereInputSchema),
              z.lazy(() => JointAccountModRequestWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => JointAccountModRequestWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => JointAccountModRequestWhereInputSchema),
              z.lazy(() => JointAccountModRequestWhereInputSchema).array(),
            ])
            .optional(),
          creatorId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          financialAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumJointAccountModRequestTypeFilterSchema),
              z.lazy(() => JointAccountModRequestTypeSchema),
            ])
            .optional(),
          transactionId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          creator: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
          account: z
            .union([
              z.lazy(() => FinancialAccountScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional(),
          transaction: z
            .union([
              z.lazy(() => TransactionNullableScalarRelationFilterSchema),
              z.lazy(() => TransactionWhereInputSchema),
            ])
            .optional()
            .nullable(),
          approvals: z
            .lazy(() => JointAccountModRequestApprovalListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    );

export const JointAccountModRequestOrderByWithAggregationInputSchema: z.ZodType<Prisma.JointAccountModRequestOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      transactionId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => JointAccountModRequestCountOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => JointAccountModRequestMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => JointAccountModRequestMinOrderByAggregateInputSchema)
        .optional(),
    })
    .strict();

export const JointAccountModRequestScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.JointAccountModRequestScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(
            () => JointAccountModRequestScalarWhereWithAggregatesInputSchema,
          ),
          z
            .lazy(
              () => JointAccountModRequestScalarWhereWithAggregatesInputSchema,
            )
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountModRequestScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(
            () => JointAccountModRequestScalarWhereWithAggregatesInputSchema,
          ),
          z
            .lazy(
              () => JointAccountModRequestScalarWhereWithAggregatesInputSchema,
            )
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      creatorId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(
            () => EnumJointAccountModRequestTypeWithAggregatesFilterSchema,
          ),
          z.lazy(() => JointAccountModRequestTypeSchema),
        ])
        .optional(),
      transactionId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalWhereInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereInputSchema),
          z.lazy(() => JointAccountModRequestApprovalWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereInputSchema),
          z.lazy(() => JointAccountModRequestApprovalWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      jointAccountModRequestId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      approverId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumJointAccountRequestStatusFilterSchema),
          z.lazy(() => JointAccountRequestStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      request: z
        .union([
          z.lazy(() => JointAccountModRequestScalarRelationFilterSchema),
          z.lazy(() => JointAccountModRequestWhereInputSchema),
        ])
        .optional(),
      approver: z
        .union([
          z.lazy(() => UserScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalOrderByWithRelationInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      jointAccountModRequestId: z.lazy(() => SortOrderSchema).optional(),
      approverId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      request: z
        .lazy(() => JointAccountModRequestOrderByWithRelationInputSchema)
        .optional(),
      approver: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalWhereUniqueInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => JointAccountModRequestApprovalWhereInputSchema),
              z
                .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
                .array(),
            ])
            .optional(),
          OR: z
            .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => JointAccountModRequestApprovalWhereInputSchema),
              z
                .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
                .array(),
            ])
            .optional(),
          jointAccountModRequestId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          approverId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumJointAccountRequestStatusFilterSchema),
              z.lazy(() => JointAccountRequestStatusSchema),
            ])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          request: z
            .union([
              z.lazy(() => JointAccountModRequestScalarRelationFilterSchema),
              z.lazy(() => JointAccountModRequestWhereInputSchema),
            ])
            .optional(),
          approver: z
            .union([
              z.lazy(() => UserScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const JointAccountModRequestApprovalOrderByWithAggregationInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      jointAccountModRequestId: z.lazy(() => SortOrderSchema).optional(),
      approverId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(
          () => JointAccountModRequestApprovalCountOrderByAggregateInputSchema,
        )
        .optional(),
      _max: z
        .lazy(
          () => JointAccountModRequestApprovalMaxOrderByAggregateInputSchema,
        )
        .optional(),
      _min: z
        .lazy(
          () => JointAccountModRequestApprovalMinOrderByAggregateInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema,
            )
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(
          () =>
            JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema,
        )
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema,
            )
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      jointAccountModRequestId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      approverId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumJointAccountRequestStatusWithAggregatesFilterSchema),
          z.lazy(() => JointAccountRequestStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanWhereInputSchema: z.ZodType<Prisma.InvestmentPlanWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InvestmentPlanWhereInputSchema),
          z.lazy(() => InvestmentPlanWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => InvestmentPlanWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InvestmentPlanWhereInputSchema),
          z.lazy(() => InvestmentPlanWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      category: z
        .union([
          z.lazy(() => EnumInvestmentPlanCategoryFilterSchema),
          z.lazy(() => InvestmentPlanCategorySchema),
        ])
        .optional(),
      minimumDeposit: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      maximumDeposit: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      duration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      profitDistribution: z
        .union([
          z.lazy(() => EnumProfitDistributionFilterSchema),
          z.lazy(() => ProfitDistributionSchema),
        ])
        .optional(),
      percentageTotalReturn: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      percentagePeriodicReturn: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      terminationFee: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const InvestmentPlanOrderByWithRelationInputSchema: z.ZodType<Prisma.InvestmentPlanOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentPlanWhereUniqueInputSchema: z.ZodType<Prisma.InvestmentPlanWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => InvestmentPlanWhereInputSchema),
              z.lazy(() => InvestmentPlanWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => InvestmentPlanWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => InvestmentPlanWhereInputSchema),
              z.lazy(() => InvestmentPlanWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          category: z
            .union([
              z.lazy(() => EnumInvestmentPlanCategoryFilterSchema),
              z.lazy(() => InvestmentPlanCategorySchema),
            ])
            .optional(),
          minimumDeposit: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          maximumDeposit: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          duration: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          profitDistribution: z
            .union([
              z.lazy(() => EnumProfitDistributionFilterSchema),
              z.lazy(() => ProfitDistributionSchema),
            ])
            .optional(),
          percentageTotalReturn: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          percentagePeriodicReturn: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          terminationFee: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
        })
        .strict(),
    );

export const InvestmentPlanOrderByWithAggregationInputSchema: z.ZodType<Prisma.InvestmentPlanOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => InvestmentPlanCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z
        .lazy(() => InvestmentPlanAvgOrderByAggregateInputSchema)
        .optional(),
      _max: z
        .lazy(() => InvestmentPlanMaxOrderByAggregateInputSchema)
        .optional(),
      _min: z
        .lazy(() => InvestmentPlanMinOrderByAggregateInputSchema)
        .optional(),
      _sum: z
        .lazy(() => InvestmentPlanSumOrderByAggregateInputSchema)
        .optional(),
    })
    .strict();

export const InvestmentPlanScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.InvestmentPlanScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InvestmentPlanScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => InvestmentPlanScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => InvestmentPlanScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InvestmentPlanScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => InvestmentPlanScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      category: z
        .union([
          z.lazy(() => EnumInvestmentPlanCategoryWithAggregatesFilterSchema),
          z.lazy(() => InvestmentPlanCategorySchema),
        ])
        .optional(),
      minimumDeposit: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      maximumDeposit: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      duration: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => EnumProfitDistributionWithAggregatesFilterSchema),
          z.lazy(() => ProfitDistributionSchema),
        ])
        .optional(),
      percentageTotalReturn: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      percentagePeriodicReturn: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      terminationFee: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentWhereInputSchema: z.ZodType<Prisma.InvestmentWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InvestmentWhereInputSchema),
          z.lazy(() => InvestmentWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => InvestmentWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InvestmentWhereInputSchema),
          z.lazy(() => InvestmentWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      investorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      deposit: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      investmentName: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      totalProfit: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      profitCount: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumInvestmentStatusFilterSchema),
          z.lazy(() => InvestmentStatusSchema),
        ])
        .optional(),
      pausedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      pausedReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      closedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      closedReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => EnumInvestmentPlanCategoryFilterSchema),
          z.lazy(() => InvestmentPlanCategorySchema),
        ])
        .optional(),
      daysCompleted: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      duration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      totalReturn: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      periodicReturn: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => EnumProfitDistributionFilterSchema),
          z.lazy(() => ProfitDistributionSchema),
        ])
        .optional(),
      terminationFee: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      investor: z
        .union([
          z.lazy(() => AccountUserScalarRelationFilterSchema),
          z.lazy(() => AccountUserWhereInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(() => TransactionListRelationFilterSchema)
        .optional(),
      financialAccount: z
        .union([
          z.lazy(() => FinancialAccountScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentOrderByWithRelationInputSchema: z.ZodType<Prisma.InvestmentOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      investorId: z.lazy(() => SortOrderSchema).optional(),
      deposit: z.lazy(() => SortOrderSchema).optional(),
      investmentName: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      pausedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      pausedReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      closedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      closedReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      terminatedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      terminatedReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      investor: z
        .lazy(() => AccountUserOrderByWithRelationInputSchema)
        .optional(),
      transactions: z
        .lazy(() => TransactionOrderByRelationAggregateInputSchema)
        .optional(),
      financialAccount: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict();

export const InvestmentWhereUniqueInputSchema: z.ZodType<Prisma.InvestmentWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => InvestmentWhereInputSchema),
              z.lazy(() => InvestmentWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => InvestmentWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => InvestmentWhereInputSchema),
              z.lazy(() => InvestmentWhereInputSchema).array(),
            ])
            .optional(),
          financialAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          investorId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          deposit: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          investmentName: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          totalProfit: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          profitCount: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumInvestmentStatusFilterSchema),
              z.lazy(() => InvestmentStatusSchema),
            ])
            .optional(),
          pausedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          pausedReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          closedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          closedReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          terminatedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          terminatedReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          category: z
            .union([
              z.lazy(() => EnumInvestmentPlanCategoryFilterSchema),
              z.lazy(() => InvestmentPlanCategorySchema),
            ])
            .optional(),
          daysCompleted: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          duration: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          totalReturn: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          periodicReturn: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          profitDistribution: z
            .union([
              z.lazy(() => EnumProfitDistributionFilterSchema),
              z.lazy(() => ProfitDistributionSchema),
            ])
            .optional(),
          terminationFee: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          investor: z
            .union([
              z.lazy(() => AccountUserScalarRelationFilterSchema),
              z.lazy(() => AccountUserWhereInputSchema),
            ])
            .optional(),
          transactions: z
            .lazy(() => TransactionListRelationFilterSchema)
            .optional(),
          financialAccount: z
            .union([
              z.lazy(() => FinancialAccountScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional(),
        })
        .strict(),
    );

export const InvestmentOrderByWithAggregationInputSchema: z.ZodType<Prisma.InvestmentOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      investorId: z.lazy(() => SortOrderSchema).optional(),
      deposit: z.lazy(() => SortOrderSchema).optional(),
      investmentName: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      pausedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      pausedReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      closedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      closedReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      terminatedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      terminatedReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => InvestmentCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => InvestmentAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => InvestmentMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => InvestmentMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => InvestmentSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const InvestmentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.InvestmentScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InvestmentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => InvestmentScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => InvestmentScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InvestmentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => InvestmentScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      investorId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      deposit: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      investmentName: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      totalProfit: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      profitCount: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumInvestmentStatusWithAggregatesFilterSchema),
          z.lazy(() => InvestmentStatusSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => EnumInvestmentPlanCategoryWithAggregatesFilterSchema),
          z.lazy(() => InvestmentPlanCategorySchema),
        ])
        .optional(),
      daysCompleted: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      duration: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      totalReturn: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      periodicReturn: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => EnumProfitDistributionWithAggregatesFilterSchema),
          z.lazy(() => ProfitDistributionSchema),
        ])
        .optional(),
      terminationFee: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const TransactionWhereInputSchema: z.ZodType<Prisma.TransactionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TransactionWhereInputSchema),
          z.lazy(() => TransactionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => TransactionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TransactionWhereInputSchema),
          z.lazy(() => TransactionWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      amount: z.union([z.lazy(() => FloatFilterSchema), z.number()]).optional(),
      currency: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      USDAmount: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      rate: z.union([z.lazy(() => FloatFilterSchema), z.number()]).optional(),
      charges: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumTransactionTypeFilterSchema),
          z.lazy(() => TransactionTypeSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      recipientAccountId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      investmentId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumTransactionStatusFilterSchema),
          z.lazy(() => TransactionStatusSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      failedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      failReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      bank: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      bankAccount: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      initiator: z
        .union([
          z.lazy(() => AccountUserScalarRelationFilterSchema),
          z.lazy(() => AccountUserWhereInputSchema),
        ])
        .optional(),
      financialAccount: z
        .union([
          z.lazy(() => FinancialAccountScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional(),
      recipientAccount: z
        .union([
          z.lazy(() => FinancialAccountNullableScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional()
        .nullable(),
      investment: z
        .union([
          z.lazy(() => InvestmentNullableScalarRelationFilterSchema),
          z.lazy(() => InvestmentWhereInputSchema),
        ])
        .optional()
        .nullable(),
      jointAccountModRequests: z
        .lazy(() => JointAccountModRequestListRelationFilterSchema)
        .optional(),
      parentTransaction: z
        .union([
          z.lazy(() => TransactionNullableScalarRelationFilterSchema),
          z.lazy(() => TransactionWhereInputSchema),
        ])
        .optional()
        .nullable(),
      childTransactions: z
        .lazy(() => TransactionListRelationFilterSchema)
        .optional(),
    })
    .strict();

export const TransactionOrderByWithRelationInputSchema: z.ZodType<Prisma.TransactionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      initiatorAccountId: z.lazy(() => SortOrderSchema).optional(),
      recipientAccountId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      investmentId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      parentTransactionId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      failedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      failReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      depositWalletAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      depositWalletAddressNetwork: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      withdrawalWalletAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      bank: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      bankAccount: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      initiator: z
        .lazy(() => AccountUserOrderByWithRelationInputSchema)
        .optional(),
      financialAccount: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
      recipientAccount: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
      investment: z
        .lazy(() => InvestmentOrderByWithRelationInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(() => JointAccountModRequestOrderByRelationAggregateInputSchema)
        .optional(),
      parentTransaction: z
        .lazy(() => TransactionOrderByWithRelationInputSchema)
        .optional(),
      childTransactions: z
        .lazy(() => TransactionOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const TransactionWhereUniqueInputSchema: z.ZodType<Prisma.TransactionWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => TransactionWhereInputSchema),
              z.lazy(() => TransactionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => TransactionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => TransactionWhereInputSchema),
              z.lazy(() => TransactionWhereInputSchema).array(),
            ])
            .optional(),
          amount: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          currency: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          USDAmount: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          rate: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          charges: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          financialAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          type: z
            .union([
              z.lazy(() => EnumTransactionTypeFilterSchema),
              z.lazy(() => TransactionTypeSchema),
            ])
            .optional(),
          initiatorAccountId: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          recipientAccountId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          investmentId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          status: z
            .union([
              z.lazy(() => EnumTransactionStatusFilterSchema),
              z.lazy(() => TransactionStatusSchema),
            ])
            .optional(),
          parentTransactionId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          approvedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          failedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          failReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          depositWalletAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          depositWalletAddressNetwork: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          withdrawalWalletAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          withdrawalWalletAddressNetwork: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          bank: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          bankAccount: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          initiator: z
            .union([
              z.lazy(() => AccountUserScalarRelationFilterSchema),
              z.lazy(() => AccountUserWhereInputSchema),
            ])
            .optional(),
          financialAccount: z
            .union([
              z.lazy(() => FinancialAccountScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional(),
          recipientAccount: z
            .union([
              z.lazy(() => FinancialAccountNullableScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional()
            .nullable(),
          investment: z
            .union([
              z.lazy(() => InvestmentNullableScalarRelationFilterSchema),
              z.lazy(() => InvestmentWhereInputSchema),
            ])
            .optional()
            .nullable(),
          jointAccountModRequests: z
            .lazy(() => JointAccountModRequestListRelationFilterSchema)
            .optional(),
          parentTransaction: z
            .union([
              z.lazy(() => TransactionNullableScalarRelationFilterSchema),
              z.lazy(() => TransactionWhereInputSchema),
            ])
            .optional()
            .nullable(),
          childTransactions: z
            .lazy(() => TransactionListRelationFilterSchema)
            .optional(),
        })
        .strict(),
    );

export const TransactionOrderByWithAggregationInputSchema: z.ZodType<Prisma.TransactionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      initiatorAccountId: z.lazy(() => SortOrderSchema).optional(),
      recipientAccountId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      investmentId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      parentTransactionId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      failedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      failReason: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      depositWalletAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      depositWalletAddressNetwork: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      withdrawalWalletAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      bank: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      bankAccount: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => TransactionCountOrderByAggregateInputSchema)
        .optional(),
      _avg: z.lazy(() => TransactionAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => TransactionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => TransactionMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => TransactionSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const TransactionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.TransactionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TransactionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => TransactionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => TransactionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TransactionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => TransactionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      amount: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      currency: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      USDAmount: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      rate: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      charges: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumTransactionTypeWithAggregatesFilterSchema),
          z.lazy(() => TransactionTypeSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      recipientAccountId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumTransactionStatusWithAggregatesFilterSchema),
          z.lazy(() => TransactionStatusSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const NotificationWhereInputSchema: z.ZodType<Prisma.NotificationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NotificationWhereInputSchema),
          z.lazy(() => NotificationWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => NotificationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NotificationWhereInputSchema),
          z.lazy(() => NotificationWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      body: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      bodyType: z
        .union([
          z.lazy(() => EnumNotificationBodyTypeFilterSchema),
          z.lazy(() => NotificationBodyTypeSchema),
        ])
        .optional(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      link: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      isRead: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      user: z
        .union([
          z.lazy(() => UserNullableScalarRelationFilterSchema),
          z.lazy(() => UserWhereInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccount: z
        .union([
          z.lazy(() => FinancialAccountNullableScalarRelationFilterSchema),
          z.lazy(() => FinancialAccountWhereInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NotificationOrderByWithRelationInputSchema: z.ZodType<Prisma.NotificationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      bodyType: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      link: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      financialAccount: z
        .lazy(() => FinancialAccountOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict();

export const NotificationWhereUniqueInputSchema: z.ZodType<Prisma.NotificationWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => NotificationWhereInputSchema),
              z.lazy(() => NotificationWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => NotificationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => NotificationWhereInputSchema),
              z.lazy(() => NotificationWhereInputSchema).array(),
            ])
            .optional(),
          title: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          body: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          bodyType: z
            .union([
              z.lazy(() => EnumNotificationBodyTypeFilterSchema),
              z.lazy(() => NotificationBodyTypeSchema),
            ])
            .optional(),
          userId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          financialAccountId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          link: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          isRead: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          user: z
            .union([
              z.lazy(() => UserNullableScalarRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional()
            .nullable(),
          financialAccount: z
            .union([
              z.lazy(() => FinancialAccountNullableScalarRelationFilterSchema),
              z.lazy(() => FinancialAccountWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict(),
    );

export const NotificationOrderByWithAggregationInputSchema: z.ZodType<Prisma.NotificationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      bodyType: z.lazy(() => SortOrderSchema).optional(),
      userId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      link: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => NotificationCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => NotificationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => NotificationMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const NotificationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.NotificationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => NotificationScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => NotificationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NotificationScalarWhereWithAggregatesInputSchema),
          z
            .lazy(() => NotificationScalarWhereWithAggregatesInputSchema)
            .array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      title: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      body: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => EnumNotificationBodyTypeWithAggregatesFilterSchema),
          z.lazy(() => NotificationBodyTypeSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const CurrencyWhereInputSchema: z.ZodType<Prisma.CurrencyWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CurrencyWhereInputSchema),
        z.lazy(() => CurrencyWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => CurrencyWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CurrencyWhereInputSchema),
        z.lazy(() => CurrencyWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    symbol: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    image: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    rate: z.union([z.lazy(() => FloatFilterSchema), z.number()]).optional(),
    rateUpdatedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    walletAddress: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    walletAddressNetwork: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    allowWithdrawal: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
    withdrawalCharge: z
      .union([z.lazy(() => FloatFilterSchema), z.number()])
      .optional(),
    createdAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
    updatedAt: z
      .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
      .optional(),
  })
  .strict();

export const CurrencyOrderByWithRelationInputSchema: z.ZodType<Prisma.CurrencyOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      symbol: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      rateUpdatedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      walletAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      walletAddressNetwork: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      allowWithdrawal: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CurrencyWhereUniqueInputSchema: z.ZodType<Prisma.CurrencyWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().uuid(),
        symbol: z.string(),
      }),
      z.object({
        id: z.string().uuid(),
      }),
      z.object({
        symbol: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          symbol: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CurrencyWhereInputSchema),
              z.lazy(() => CurrencyWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CurrencyWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CurrencyWhereInputSchema),
              z.lazy(() => CurrencyWhereInputSchema).array(),
            ])
            .optional(),
          name: z
            .union([z.lazy(() => StringFilterSchema), z.string()])
            .optional(),
          image: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          rate: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          rateUpdatedAt: z
            .union([
              z.lazy(() => DateTimeNullableFilterSchema),
              z.coerce.date(),
            ])
            .optional()
            .nullable(),
          walletAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          walletAddressNetwork: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          allowWithdrawal: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          withdrawalCharge: z
            .union([z.lazy(() => FloatFilterSchema), z.number()])
            .optional(),
          createdAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
          updatedAt: z
            .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
            .optional(),
        })
        .strict(),
    );

export const CurrencyOrderByWithAggregationInputSchema: z.ZodType<Prisma.CurrencyOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      symbol: z.lazy(() => SortOrderSchema).optional(),
      image: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      rateUpdatedAt: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      walletAddress: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      walletAddressNetwork: z
        .union([
          z.lazy(() => SortOrderSchema),
          z.lazy(() => SortOrderInputSchema),
        ])
        .optional(),
      allowWithdrawal: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CurrencyCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CurrencyAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CurrencyMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CurrencyMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CurrencySumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CurrencyScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CurrencyScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CurrencyScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CurrencyScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CurrencyScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CurrencyScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CurrencyScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      symbol: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      image: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      rate: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      rateUpdatedAt: z
        .union([
          z.lazy(() => DateTimeNullableWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional()
        .nullable(),
      walletAddress: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      walletAddressNetwork: z
        .union([
          z.lazy(() => StringNullableWithAggregatesFilterSchema),
          z.string(),
        ])
        .optional()
        .nullable(),
      allowWithdrawal: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      withdrawalCharge: z
        .union([z.lazy(() => FloatWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.lazy(() => DateTimeWithAggregatesFilterSchema),
          z.coerce.date(),
        ])
        .optional(),
    })
    .strict();

export const SettingsWhereInputSchema: z.ZodType<Prisma.SettingsWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SettingsWhereInputSchema),
        z.lazy(() => SettingsWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => SettingsWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SettingsWhereInputSchema),
        z.lazy(() => SettingsWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    allowWithdrawals: z
      .union([z.lazy(() => BoolFilterSchema), z.boolean()])
      .optional(),
  })
  .strict();

export const SettingsOrderByWithRelationInputSchema: z.ZodType<Prisma.SettingsOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawals: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SettingsWhereUniqueInputSchema: z.ZodType<Prisma.SettingsWhereUniqueInput> =
  z
    .object({
      id: z.string().uuid(),
    })
    .and(
      z
        .object({
          id: z.string().uuid().optional(),
          AND: z
            .union([
              z.lazy(() => SettingsWhereInputSchema),
              z.lazy(() => SettingsWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => SettingsWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SettingsWhereInputSchema),
              z.lazy(() => SettingsWhereInputSchema).array(),
            ])
            .optional(),
          allowWithdrawals: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
        })
        .strict(),
    );

export const SettingsOrderByWithAggregationInputSchema: z.ZodType<Prisma.SettingsOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawals: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => SettingsCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SettingsMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SettingsMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const SettingsScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SettingsScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SettingsScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SettingsScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => SettingsScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SettingsScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SettingsScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      allowWithdrawals: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
    })
    .strict();

export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    name: z.string(),
    email: z.string(),
    emailVerified: z.boolean(),
    image: z.string().optional().nullable(),
    role: z.lazy(() => UserRoleSchema).optional(),
    banned: z.boolean().optional().nullable(),
    banReason: z.string().optional().nullable(),
    banExpires: z.coerce.date().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    profile: z
      .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
      .optional(),
    sessions: z
      .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
      .optional(),
    accounts: z
      .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
      .optional(),
    createdAccounts: z
      .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
      .optional(),
    accountMemberships: z
      .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
      .optional(),
    createdJointAccountRequests: z
      .lazy(() => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema)
      .optional(),
    receivedJointAccountRequests: z
      .lazy(
        () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
      )
      .optional(),
    createdJointAccountModRequests: z
      .lazy(
        () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
      )
      .optional(),
    notifications: z
      .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
      .optional(),
    approvedJointAccountModRequests: z
      .lazy(
        () =>
          JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
      )
      .optional(),
  })
  .strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUpdateInputSchema: z.ZodType<Prisma.UserUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    email: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    emailVerified: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    image: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    role: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    banned: z
      .union([
        z.boolean(),
        z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    banReason: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    banExpires: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    profile: z
      .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
      .optional(),
    sessions: z
      .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    accounts: z
      .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    createdAccounts: z
      .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
      .optional(),
    accountMemberships: z
      .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    createdJointAccountRequests: z
      .lazy(() => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema)
      .optional(),
    receivedJointAccountRequests: z
      .lazy(
        () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
      )
      .optional(),
    createdJointAccountModRequests: z
      .lazy(
        () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
      )
      .optional(),
    notifications: z
      .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    approvedJointAccountModRequests: z
      .lazy(
        () =>
          JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
      )
      .optional(),
  })
  .strict();

export const UserUncheckedUpdateInputSchema: z.ZodType<Prisma.UserUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateManyInputSchema: z.ZodType<Prisma.UserCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const UserUpdateManyMutationInputSchema: z.ZodType<Prisma.UserUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionCreateInputSchema: z.ZodType<Prisma.SessionCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    token: z.string(),
    expiresAt: z.coerce.date(),
    ipAddress: z.string().optional().nullable(),
    userAgent: z.string().optional().nullable(),
    impersonatedBy: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutSessionsInputSchema),
  })
  .strict();

export const SessionUncheckedCreateInputSchema: z.ZodType<Prisma.SessionUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      impersonatedBy: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SessionUpdateInputSchema: z.ZodType<Prisma.SessionUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    token: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    expiresAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    ipAddress: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    userAgent: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    impersonatedBy: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutSessionsNestedInputSchema)
      .optional(),
  })
  .strict();

export const SessionUncheckedUpdateInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionCreateManyInputSchema: z.ZodType<Prisma.SessionCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      impersonatedBy: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SessionUpdateManyMutationInputSchema: z.ZodType<Prisma.SessionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountCreateInputSchema: z.ZodType<Prisma.AccountCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    accountId: z.string(),
    providerId: z.string(),
    accessToken: z.string().optional().nullable(),
    refreshToken: z.string().optional().nullable(),
    accessTokenExpiresAt: z.coerce.date().optional().nullable(),
    refreshTokenExpiresAt: z.coerce.date().optional().nullable(),
    scope: z.string().optional().nullable(),
    idToken: z.string().optional().nullable(),
    password: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutAccountsInputSchema),
  })
  .strict();

export const AccountUncheckedCreateInputSchema: z.ZodType<Prisma.AccountUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      accountId: z.string(),
      providerId: z.string(),
      accessToken: z.string().optional().nullable(),
      refreshToken: z.string().optional().nullable(),
      accessTokenExpiresAt: z.coerce.date().optional().nullable(),
      refreshTokenExpiresAt: z.coerce.date().optional().nullable(),
      scope: z.string().optional().nullable(),
      idToken: z.string().optional().nullable(),
      password: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUpdateInputSchema: z.ZodType<Prisma.AccountUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    accountId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    providerId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    accessToken: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    refreshToken: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    accessTokenExpiresAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    refreshTokenExpiresAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    scope: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    idToken: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    password: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutAccountsNestedInputSchema)
      .optional(),
  })
  .strict();

export const AccountUncheckedUpdateInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accessToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountCreateManyInputSchema: z.ZodType<Prisma.AccountCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      accountId: z.string(),
      providerId: z.string(),
      accessToken: z.string().optional().nullable(),
      refreshToken: z.string().optional().nullable(),
      accessTokenExpiresAt: z.coerce.date().optional().nullable(),
      refreshTokenExpiresAt: z.coerce.date().optional().nullable(),
      scope: z.string().optional().nullable(),
      idToken: z.string().optional().nullable(),
      password: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUpdateManyMutationInputSchema: z.ZodType<Prisma.AccountUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accessToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accessToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const VerificationCreateInputSchema: z.ZodType<Prisma.VerificationCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      identifier: z.string(),
      value: z.string(),
      expiresAt: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const VerificationUncheckedCreateInputSchema: z.ZodType<Prisma.VerificationUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      identifier: z.string(),
      value: z.string(),
      expiresAt: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const VerificationUpdateInputSchema: z.ZodType<Prisma.VerificationUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const VerificationUncheckedUpdateInputSchema: z.ZodType<Prisma.VerificationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const VerificationCreateManyInputSchema: z.ZodType<Prisma.VerificationCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      identifier: z.string(),
      value: z.string(),
      expiresAt: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const VerificationUpdateManyMutationInputSchema: z.ZodType<Prisma.VerificationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const VerificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.VerificationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      identifier: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      value: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ProfileCreateInputSchema: z.ZodType<Prisma.ProfileCreateInput> = z
  .object({
    id: z.string().uuid().optional(),
    address: z.string().optional().nullable(),
    country: z.string().optional().nullable(),
    state: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    postalCode: z.string().optional().nullable(),
    governmentId: z.string().optional().nullable(),
    governmentIdType: z
      .lazy(() => GovernmentIdTypeSchema)
      .optional()
      .nullable(),
    governmentIdExt: z.string().optional().nullable(),
    kycStatus: z
      .lazy(() => KycStatusSchema)
      .optional()
      .nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutProfileInputSchema),
  })
  .strict();

export const ProfileUncheckedCreateInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      address: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      state: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      postalCode: z.string().optional().nullable(),
      governmentId: z.string().optional().nullable(),
      governmentIdType: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      governmentIdExt: z.string().optional().nullable(),
      kycStatus: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ProfileUpdateInputSchema: z.ZodType<Prisma.ProfileUpdateInput> = z
  .object({
    id: z
      .union([
        z.string().uuid(),
        z.lazy(() => StringFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    address: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    country: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    state: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    city: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    postalCode: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    governmentId: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    governmentIdType: z
      .union([
        z.lazy(() => GovernmentIdTypeSchema),
        z.lazy(
          () => NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema,
        ),
      ])
      .optional()
      .nullable(),
    governmentIdExt: z
      .union([
        z.string(),
        z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    kycStatus: z
      .union([
        z.lazy(() => KycStatusSchema),
        z.lazy(() => NullableEnumKycStatusFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    updatedAt: z
      .union([
        z.coerce.date(),
        z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    user: z
      .lazy(() => UserUpdateOneRequiredWithoutProfileNestedInputSchema)
      .optional(),
  })
  .strict();

export const ProfileUncheckedUpdateInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      state: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      postalCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentIdType: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional()
        .nullable(),
      governmentIdExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      kycStatus: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NullableEnumKycStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ProfileCreateManyInputSchema: z.ZodType<Prisma.ProfileCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      address: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      state: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      postalCode: z.string().optional().nullable(),
      governmentId: z.string().optional().nullable(),
      governmentIdType: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      governmentIdExt: z.string().optional().nullable(),
      kycStatus: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ProfileUpdateManyMutationInputSchema: z.ZodType<Prisma.ProfileUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      state: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      postalCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentIdType: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional()
        .nullable(),
      governmentIdExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      kycStatus: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NullableEnumKycStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ProfileUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      state: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      postalCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentIdType: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional()
        .nullable(),
      governmentIdExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      kycStatus: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NullableEnumKycStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileCreateInputSchema: z.ZodType<Prisma.BusinessProfileCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      address: z.string().optional().nullable(),
      creationMonth: z.string().optional().nullable(),
      creationYear: z.number().int().optional().nullable(),
      proofOfAddress: z.string().optional().nullable(),
      proofOfAddressExt: z.string().optional().nullable(),
      certificate: z.string().optional().nullable(),
      certificateExt: z.string().optional().nullable(),
      approved: z.boolean(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      account: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutBusinessProfileInputSchema,
      ),
    })
    .strict();

export const BusinessProfileUncheckedCreateInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      address: z.string().optional().nullable(),
      creationMonth: z.string().optional().nullable(),
      creationYear: z.number().int().optional().nullable(),
      proofOfAddress: z.string().optional().nullable(),
      proofOfAddressExt: z.string().optional().nullable(),
      certificate: z.string().optional().nullable(),
      certificateExt: z.string().optional().nullable(),
      approved: z.boolean(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const BusinessProfileUpdateInputSchema: z.ZodType<Prisma.BusinessProfileUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      account: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutBusinessProfileNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const BusinessProfileUncheckedUpdateInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileCreateManyInputSchema: z.ZodType<Prisma.BusinessProfileCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      address: z.string().optional().nullable(),
      creationMonth: z.string().optional().nullable(),
      creationYear: z.number().int().optional().nullable(),
      proofOfAddress: z.string().optional().nullable(),
      proofOfAddressExt: z.string().optional().nullable(),
      certificate: z.string().optional().nullable(),
      certificateExt: z.string().optional().nullable(),
      approved: z.boolean(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const BusinessProfileUpdateManyMutationInputSchema: z.ZodType<Prisma.BusinessProfileUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileUncheckedUpdateManyInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountCreateInputSchema: z.ZodType<Prisma.FinancialAccountCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateInputSchema: z.ZodType<Prisma.FinancialAccountUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateManyInputSchema: z.ZodType<Prisma.FinancialAccountCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const FinancialAccountUpdateManyMutationInputSchema: z.ZodType<Prisma.FinancialAccountUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateManyInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserCreateInputSchema: z.ZodType<Prisma.AccountUserCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(
        () => UserCreateNestedOneWithoutAccountMembershipsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutAccountUsersInputSchema,
      ),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInitiatorInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentCreateNestedManyWithoutInvestorInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedCreateInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      financialAccountId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedCreateNestedManyWithoutInitiatorInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedCreateNestedManyWithoutInvestorInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserUpdateInputSchema: z.ZodType<Prisma.AccountUserUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutAccountMembershipsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutAccountUsersNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInitiatorNestedInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentUpdateManyWithoutInvestorNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedUpdateManyWithoutInitiatorNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedUpdateManyWithoutInvestorNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserCreateManyInputSchema: z.ZodType<Prisma.AccountUserCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      financialAccountId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUserUpdateManyMutationInputSchema: z.ZodType<Prisma.AccountUserUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestCreateInputSchema: z.ZodType<Prisma.JointAccountRequestCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedJointAccountRequestsInputSchema,
      ),
      recipient: z
        .lazy(
          () =>
            UserCreateNestedOneWithoutReceivedJointAccountRequestsInputSchema,
        )
        .optional(),
      financialAccount: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountRequestsInputSchema,
      ),
    })
    .strict();

export const JointAccountRequestUncheckedCreateInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      recipientId: z.string().optional().nullable(),
      financialAccountId: z.string(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestUpdateInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountRequestsNestedInputSchema,
        )
        .optional(),
      recipient: z
        .lazy(
          () =>
            UserUpdateOneWithoutReceivedJointAccountRequestsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestCreateManyInputSchema: z.ZodType<Prisma.JointAccountRequestCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      recipientId: z.string().optional().nullable(),
      financialAccountId: z.string(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestUpdateManyMutationInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () =>
          UserCreateNestedOneWithoutCreatedJointAccountModRequestsInputSchema,
      ),
      account: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountModRequestsInputSchema,
      ),
      transaction: z
        .lazy(
          () =>
            TransactionCreateNestedOneWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpdateInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      account: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      transaction: z
        .lazy(
          () =>
            TransactionUpdateOneWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateManyInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestUpdateManyMutationInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      request: z.lazy(
        () => JointAccountModRequestCreateNestedOneWithoutApprovalsInputSchema,
      ),
      approver: z.lazy(
        () =>
          UserCreateNestedOneWithoutApprovedJointAccountModRequestsInputSchema,
      ),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedCreateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      jointAccountModRequestId: z.string(),
      approverId: z.string(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      request: z
        .lazy(
          () =>
            JointAccountModRequestUpdateOneRequiredWithoutApprovalsNestedInputSchema,
        )
        .optional(),
      approver: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutApprovedJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequestId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approverId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      jointAccountModRequestId: z.string(),
      approverId: z.string(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyMutationInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateManyInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequestId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approverId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanCreateInputSchema: z.ZodType<Prisma.InvestmentPlanCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      minimumDeposit: z.number(),
      maximumDeposit: z.number(),
      duration: z.number().int(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      percentageTotalReturn: z.number(),
      percentagePeriodicReturn: z.number(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentPlanUncheckedCreateInputSchema: z.ZodType<Prisma.InvestmentPlanUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      minimumDeposit: z.number(),
      maximumDeposit: z.number(),
      duration: z.number().int(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      percentageTotalReturn: z.number(),
      percentagePeriodicReturn: z.number(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentPlanUpdateInputSchema: z.ZodType<Prisma.InvestmentPlanUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      minimumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      maximumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentageTotalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentagePeriodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanUncheckedUpdateInputSchema: z.ZodType<Prisma.InvestmentPlanUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      minimumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      maximumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentageTotalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentagePeriodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanCreateManyInputSchema: z.ZodType<Prisma.InvestmentPlanCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      minimumDeposit: z.number(),
      maximumDeposit: z.number(),
      duration: z.number().int(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      percentageTotalReturn: z.number(),
      percentagePeriodicReturn: z.number(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentPlanUpdateManyMutationInputSchema: z.ZodType<Prisma.InvestmentPlanUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      minimumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      maximumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentageTotalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentagePeriodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanUncheckedUpdateManyInputSchema: z.ZodType<Prisma.InvestmentPlanUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      minimumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      maximumDeposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentageTotalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      percentagePeriodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentCreateInputSchema: z.ZodType<Prisma.InvestmentCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      investor: z.lazy(
        () => AccountUserCreateNestedOneWithoutInvestmentsInputSchema,
      ),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInvestmentInputSchema)
        .optional(),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutInvestmentsInputSchema,
      ),
    })
    .strict();

export const InvestmentUncheckedCreateInputSchema: z.ZodType<Prisma.InvestmentUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      investorId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutInvestmentInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUpdateInputSchema: z.ZodType<Prisma.InvestmentUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investor: z
        .lazy(
          () => AccountUserUpdateOneRequiredWithoutInvestmentsNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInvestmentNestedInputSchema)
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutInvestmentsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutInvestmentNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentCreateManyInputSchema: z.ZodType<Prisma.InvestmentCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      investorId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentUpdateManyMutationInputSchema: z.ZodType<Prisma.InvestmentUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionCreateInputSchema: z.ZodType<Prisma.TransactionCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUpdateInputSchema: z.ZodType<Prisma.TransactionUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateManyInputSchema: z.ZodType<Prisma.TransactionCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const TransactionUpdateManyMutationInputSchema: z.ZodType<Prisma.TransactionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationCreateInputSchema: z.ZodType<Prisma.NotificationCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z
        .lazy(() => UserCreateNestedOneWithoutNotificationsInputSchema)
        .optional(),
      financialAccount: z
        .lazy(
          () => FinancialAccountCreateNestedOneWithoutNotificationsInputSchema,
        )
        .optional(),
    })
    .strict();

export const NotificationUncheckedCreateInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      userId: z.string().optional().nullable(),
      financialAccountId: z.string().optional().nullable(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const NotificationUpdateInputSchema: z.ZodType<Prisma.NotificationUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneWithoutNotificationsNestedInputSchema)
        .optional(),
      financialAccount: z
        .lazy(
          () => FinancialAccountUpdateOneWithoutNotificationsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationCreateManyInputSchema: z.ZodType<Prisma.NotificationCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      userId: z.string().optional().nullable(),
      financialAccountId: z.string().optional().nullable(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const NotificationUpdateManyMutationInputSchema: z.ZodType<Prisma.NotificationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CurrencyCreateInputSchema: z.ZodType<Prisma.CurrencyCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      symbol: z.string(),
      image: z.string().optional().nullable(),
      rate: z.number(),
      rateUpdatedAt: z.coerce.date().optional().nullable(),
      walletAddress: z.string().optional().nullable(),
      walletAddressNetwork: z.string().optional().nullable(),
      allowWithdrawal: z.boolean().optional(),
      withdrawalCharge: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CurrencyUncheckedCreateInputSchema: z.ZodType<Prisma.CurrencyUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      symbol: z.string(),
      image: z.string().optional().nullable(),
      rate: z.number(),
      rateUpdatedAt: z.coerce.date().optional().nullable(),
      walletAddress: z.string().optional().nullable(),
      walletAddressNetwork: z.string().optional().nullable(),
      allowWithdrawal: z.boolean().optional(),
      withdrawalCharge: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CurrencyUpdateInputSchema: z.ZodType<Prisma.CurrencyUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      symbol: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rateUpdatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      allowWithdrawal: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      withdrawalCharge: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CurrencyUncheckedUpdateInputSchema: z.ZodType<Prisma.CurrencyUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      symbol: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rateUpdatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      allowWithdrawal: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      withdrawalCharge: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CurrencyCreateManyInputSchema: z.ZodType<Prisma.CurrencyCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      symbol: z.string(),
      image: z.string().optional().nullable(),
      rate: z.number(),
      rateUpdatedAt: z.coerce.date().optional().nullable(),
      walletAddress: z.string().optional().nullable(),
      walletAddressNetwork: z.string().optional().nullable(),
      allowWithdrawal: z.boolean().optional(),
      withdrawalCharge: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CurrencyUpdateManyMutationInputSchema: z.ZodType<Prisma.CurrencyUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      symbol: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rateUpdatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      allowWithdrawal: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      withdrawalCharge: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CurrencyUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CurrencyUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      symbol: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rateUpdatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      walletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      allowWithdrawal: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      withdrawalCharge: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SettingsCreateInputSchema: z.ZodType<Prisma.SettingsCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      allowWithdrawals: z.boolean(),
    })
    .strict();

export const SettingsUncheckedCreateInputSchema: z.ZodType<Prisma.SettingsUncheckedCreateInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      allowWithdrawals: z.boolean(),
    })
    .strict();

export const SettingsUpdateInputSchema: z.ZodType<Prisma.SettingsUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      allowWithdrawals: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SettingsUncheckedUpdateInputSchema: z.ZodType<Prisma.SettingsUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      allowWithdrawals: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SettingsCreateManyInputSchema: z.ZodType<Prisma.SettingsCreateManyInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      allowWithdrawals: z.boolean(),
    })
    .strict();

export const SettingsUpdateManyMutationInputSchema: z.ZodType<Prisma.SettingsUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      allowWithdrawals: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SettingsUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SettingsUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      allowWithdrawals: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const StringFilterSchema: z.ZodType<Prisma.StringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringFilterSchema)])
      .optional(),
  })
  .strict();

export const BoolFilterSchema: z.ZodType<Prisma.BoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z
      .union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)])
      .optional(),
  })
  .strict();

export const StringNullableFilterSchema: z.ZodType<Prisma.StringNullableFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const EnumUserRoleFilterSchema: z.ZodType<Prisma.EnumUserRoleFilter> = z
  .object({
    equals: z.lazy(() => UserRoleSchema).optional(),
    in: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => NestedEnumUserRoleFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const BoolNullableFilterSchema: z.ZodType<Prisma.BoolNullableFilter> = z
  .object({
    equals: z.boolean().optional().nullable(),
    not: z
      .union([z.boolean(), z.lazy(() => NestedBoolNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const DateTimeNullableFilterSchema: z.ZodType<Prisma.DateTimeNullableFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const DateTimeFilterSchema: z.ZodType<Prisma.DateTimeFilter> = z
  .object({
    equals: z.coerce.date().optional(),
    in: z.coerce.date().array().optional(),
    notIn: z.coerce.date().array().optional(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z
      .union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)])
      .optional(),
  })
  .strict();

export const ProfileNullableScalarRelationFilterSchema: z.ZodType<Prisma.ProfileNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => ProfileWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => ProfileWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const SessionListRelationFilterSchema: z.ZodType<Prisma.SessionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => SessionWhereInputSchema).optional(),
      some: z.lazy(() => SessionWhereInputSchema).optional(),
      none: z.lazy(() => SessionWhereInputSchema).optional(),
    })
    .strict();

export const AccountListRelationFilterSchema: z.ZodType<Prisma.AccountListRelationFilter> =
  z
    .object({
      every: z.lazy(() => AccountWhereInputSchema).optional(),
      some: z.lazy(() => AccountWhereInputSchema).optional(),
      none: z.lazy(() => AccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountListRelationFilterSchema: z.ZodType<Prisma.FinancialAccountListRelationFilter> =
  z
    .object({
      every: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      some: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      none: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const AccountUserListRelationFilterSchema: z.ZodType<Prisma.AccountUserListRelationFilter> =
  z
    .object({
      every: z.lazy(() => AccountUserWhereInputSchema).optional(),
      some: z.lazy(() => AccountUserWhereInputSchema).optional(),
      none: z.lazy(() => AccountUserWhereInputSchema).optional(),
    })
    .strict();

export const JointAccountRequestListRelationFilterSchema: z.ZodType<Prisma.JointAccountRequestListRelationFilter> =
  z
    .object({
      every: z.lazy(() => JointAccountRequestWhereInputSchema).optional(),
      some: z.lazy(() => JointAccountRequestWhereInputSchema).optional(),
      none: z.lazy(() => JointAccountRequestWhereInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestListRelationFilterSchema: z.ZodType<Prisma.JointAccountModRequestListRelationFilter> =
  z
    .object({
      every: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
      some: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
      none: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
    })
    .strict();

export const NotificationListRelationFilterSchema: z.ZodType<Prisma.NotificationListRelationFilter> =
  z
    .object({
      every: z.lazy(() => NotificationWhereInputSchema).optional(),
      some: z.lazy(() => NotificationWhereInputSchema).optional(),
      none: z.lazy(() => NotificationWhereInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalListRelationFilterSchema: z.ZodType<Prisma.JointAccountModRequestApprovalListRelationFilter> =
  z
    .object({
      every: z
        .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
        .optional(),
      some: z
        .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
        .optional(),
      none: z
        .lazy(() => JointAccountModRequestApprovalWhereInputSchema)
        .optional(),
    })
    .strict();

export const SortOrderInputSchema: z.ZodType<Prisma.SortOrderInput> = z
  .object({
    sort: z.lazy(() => SortOrderSchema),
    nulls: z.lazy(() => NullsOrderSchema).optional(),
  })
  .strict();

export const SessionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SessionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AccountOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const FinancialAccountOrderByRelationAggregateInputSchema: z.ZodType<Prisma.FinancialAccountOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountUserOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AccountUserOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountRequestOrderByRelationAggregateInputSchema: z.ZodType<Prisma.JointAccountRequestOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountModRequestOrderByRelationAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const NotificationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.NotificationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalOrderByRelationAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UserCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      banned: z.lazy(() => SortOrderSchema).optional(),
      banReason: z.lazy(() => SortOrderSchema).optional(),
      banExpires: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      banned: z.lazy(() => SortOrderSchema).optional(),
      banReason: z.lazy(() => SortOrderSchema).optional(),
      banExpires: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UserMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      banned: z.lazy(() => SortOrderSchema).optional(),
      banReason: z.lazy(() => SortOrderSchema).optional(),
      banExpires: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const StringWithAggregatesFilterSchema: z.ZodType<Prisma.StringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional(),
    })
    .strict();

export const BoolWithAggregatesFilterSchema: z.ZodType<Prisma.BoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional(),
    })
    .strict();

export const StringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.StringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional(),
    })
    .strict();

export const EnumUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.EnumUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
    })
    .strict();

export const BoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.BoolNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional().nullable(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
    })
    .strict();

export const DateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
    })
    .strict();

export const DateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional(),
    })
    .strict();

export const UserScalarRelationFilterSchema: z.ZodType<Prisma.UserScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => UserWhereInputSchema).optional(),
      isNot: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const SessionCountOrderByAggregateInputSchema: z.ZodType<Prisma.SessionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      impersonatedBy: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SessionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SessionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      impersonatedBy: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SessionMinOrderByAggregateInputSchema: z.ZodType<Prisma.SessionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      impersonatedBy: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountCountOrderByAggregateInputSchema: z.ZodType<Prisma.AccountCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      accountId: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      accessTokenExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      refreshTokenExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      idToken: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      accountId: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      accessTokenExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      refreshTokenExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      idToken: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountMinOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      accountId: z.lazy(() => SortOrderSchema).optional(),
      providerId: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      accessTokenExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      refreshTokenExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      idToken: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const VerificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const VerificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const VerificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.VerificationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      identifier: z.lazy(() => SortOrderSchema).optional(),
      value: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumGovernmentIdTypeNullableFilterSchema: z.ZodType<Prisma.EnumGovernmentIdTypeNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(() => NestedEnumGovernmentIdTypeNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const EnumKycStatusNullableFilterSchema: z.ZodType<Prisma.EnumKycStatusNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NestedEnumKycStatusNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const ProfileCountOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      state: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      postalCode: z.lazy(() => SortOrderSchema).optional(),
      governmentId: z.lazy(() => SortOrderSchema).optional(),
      governmentIdType: z.lazy(() => SortOrderSchema).optional(),
      governmentIdExt: z.lazy(() => SortOrderSchema).optional(),
      kycStatus: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ProfileMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      state: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      postalCode: z.lazy(() => SortOrderSchema).optional(),
      governmentId: z.lazy(() => SortOrderSchema).optional(),
      governmentIdType: z.lazy(() => SortOrderSchema).optional(),
      governmentIdExt: z.lazy(() => SortOrderSchema).optional(),
      kycStatus: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ProfileMinOrderByAggregateInputSchema: z.ZodType<Prisma.ProfileMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      state: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      postalCode: z.lazy(() => SortOrderSchema).optional(),
      governmentId: z.lazy(() => SortOrderSchema).optional(),
      governmentIdType: z.lazy(() => SortOrderSchema).optional(),
      governmentIdExt: z.lazy(() => SortOrderSchema).optional(),
      kycStatus: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumGovernmentIdTypeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumGovernmentIdTypeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NestedEnumGovernmentIdTypeNullableWithAggregatesFilterSchema,
          ),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumGovernmentIdTypeNullableFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumGovernmentIdTypeNullableFilterSchema)
        .optional(),
    })
    .strict();

export const EnumKycStatusNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumKycStatusNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NestedEnumKycStatusNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumKycStatusNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumKycStatusNullableFilterSchema).optional(),
    })
    .strict();

export const IntNullableFilterSchema: z.ZodType<Prisma.IntNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const FinancialAccountScalarRelationFilterSchema: z.ZodType<Prisma.FinancialAccountScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      isNot: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const BusinessProfileCountOrderByAggregateInputSchema: z.ZodType<Prisma.BusinessProfileCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      creationMonth: z.lazy(() => SortOrderSchema).optional(),
      creationYear: z.lazy(() => SortOrderSchema).optional(),
      proofOfAddress: z.lazy(() => SortOrderSchema).optional(),
      proofOfAddressExt: z.lazy(() => SortOrderSchema).optional(),
      certificate: z.lazy(() => SortOrderSchema).optional(),
      certificateExt: z.lazy(() => SortOrderSchema).optional(),
      approved: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BusinessProfileAvgOrderByAggregateInputSchema: z.ZodType<Prisma.BusinessProfileAvgOrderByAggregateInput> =
  z
    .object({
      creationYear: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BusinessProfileMaxOrderByAggregateInputSchema: z.ZodType<Prisma.BusinessProfileMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      creationMonth: z.lazy(() => SortOrderSchema).optional(),
      creationYear: z.lazy(() => SortOrderSchema).optional(),
      proofOfAddress: z.lazy(() => SortOrderSchema).optional(),
      proofOfAddressExt: z.lazy(() => SortOrderSchema).optional(),
      certificate: z.lazy(() => SortOrderSchema).optional(),
      certificateExt: z.lazy(() => SortOrderSchema).optional(),
      approved: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BusinessProfileMinOrderByAggregateInputSchema: z.ZodType<Prisma.BusinessProfileMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      address: z.lazy(() => SortOrderSchema).optional(),
      creationMonth: z.lazy(() => SortOrderSchema).optional(),
      creationYear: z.lazy(() => SortOrderSchema).optional(),
      proofOfAddress: z.lazy(() => SortOrderSchema).optional(),
      proofOfAddressExt: z.lazy(() => SortOrderSchema).optional(),
      certificate: z.lazy(() => SortOrderSchema).optional(),
      certificateExt: z.lazy(() => SortOrderSchema).optional(),
      approved: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BusinessProfileSumOrderByAggregateInputSchema: z.ZodType<Prisma.BusinessProfileSumOrderByAggregateInput> =
  z
    .object({
      creationYear: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const IntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.IntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedIntNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional(),
    })
    .strict();

export const EnumAccountStatusFilterSchema: z.ZodType<Prisma.EnumAccountStatusFilter> =
  z
    .object({
      equals: z.lazy(() => AccountStatusSchema).optional(),
      in: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => NestedEnumAccountStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const EnumAccountTypeFilterSchema: z.ZodType<Prisma.EnumAccountTypeFilter> =
  z
    .object({
      equals: z.lazy(() => AccountTypeSchema).optional(),
      in: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => NestedEnumAccountTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const EnumAccountOwnershipFilterSchema: z.ZodType<Prisma.EnumAccountOwnershipFilter> =
  z
    .object({
      equals: z.lazy(() => AccountOwnershipSchema).optional(),
      in: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => NestedEnumAccountOwnershipFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const FloatFilterSchema: z.ZodType<Prisma.FloatFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedFloatFilterSchema)])
      .optional(),
  })
  .strict();

export const IntFilterSchema: z.ZodType<Prisma.IntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional(),
  })
  .strict();

export const BusinessProfileNullableScalarRelationFilterSchema: z.ZodType<Prisma.BusinessProfileNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => BusinessProfileWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => BusinessProfileWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const TransactionListRelationFilterSchema: z.ZodType<Prisma.TransactionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => TransactionWhereInputSchema).optional(),
      some: z.lazy(() => TransactionWhereInputSchema).optional(),
      none: z.lazy(() => TransactionWhereInputSchema).optional(),
    })
    .strict();

export const InvestmentListRelationFilterSchema: z.ZodType<Prisma.InvestmentListRelationFilter> =
  z
    .object({
      every: z.lazy(() => InvestmentWhereInputSchema).optional(),
      some: z.lazy(() => InvestmentWhereInputSchema).optional(),
      none: z.lazy(() => InvestmentWhereInputSchema).optional(),
    })
    .strict();

export const TransactionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.TransactionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.InvestmentOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const FinancialAccountCountOrderByAggregateInputSchema: z.ZodType<Prisma.FinancialAccountCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      number: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
      firstTransactionAt: z.lazy(() => SortOrderSchema).optional(),
      lastTransactionAt: z.lazy(() => SortOrderSchema).optional(),
      closedAt: z.lazy(() => SortOrderSchema).optional(),
      dormantAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const FinancialAccountAvgOrderByAggregateInputSchema: z.ZodType<Prisma.FinancialAccountAvgOrderByAggregateInput> =
  z
    .object({
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const FinancialAccountMaxOrderByAggregateInputSchema: z.ZodType<Prisma.FinancialAccountMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      number: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
      firstTransactionAt: z.lazy(() => SortOrderSchema).optional(),
      lastTransactionAt: z.lazy(() => SortOrderSchema).optional(),
      closedAt: z.lazy(() => SortOrderSchema).optional(),
      dormantAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const FinancialAccountMinOrderByAggregateInputSchema: z.ZodType<Prisma.FinancialAccountMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      number: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
      firstTransactionAt: z.lazy(() => SortOrderSchema).optional(),
      lastTransactionAt: z.lazy(() => SortOrderSchema).optional(),
      closedAt: z.lazy(() => SortOrderSchema).optional(),
      dormantAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const FinancialAccountSumOrderByAggregateInputSchema: z.ZodType<Prisma.FinancialAccountSumOrderByAggregateInput> =
  z
    .object({
      balance: z.lazy(() => SortOrderSchema).optional(),
      totalTransactions: z.lazy(() => SortOrderSchema).optional(),
      totalInvestments: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumAccountStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumAccountStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountStatusSchema).optional(),
      in: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => NestedEnumAccountStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountStatusFilterSchema).optional(),
    })
    .strict();

export const EnumAccountTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumAccountTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountTypeSchema).optional(),
      in: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => NestedEnumAccountTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountTypeFilterSchema).optional(),
    })
    .strict();

export const EnumAccountOwnershipWithAggregatesFilterSchema: z.ZodType<Prisma.EnumAccountOwnershipWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountOwnershipSchema).optional(),
      in: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => NestedEnumAccountOwnershipWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountOwnershipFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountOwnershipFilterSchema).optional(),
    })
    .strict();

export const FloatWithAggregatesFilterSchema: z.ZodType<Prisma.FloatWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedFloatWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatFilterSchema).optional(),
    })
    .strict();

export const IntWithAggregatesFilterSchema: z.ZodType<Prisma.IntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional(),
    })
    .strict();

export const EnumAccountUserRoleFilterSchema: z.ZodType<Prisma.EnumAccountUserRoleFilter> =
  z
    .object({
      equals: z.lazy(() => AccountUserRoleSchema).optional(),
      in: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => NestedEnumAccountUserRoleFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUserIdFinancialAccountIdCompoundUniqueInputSchema: z.ZodType<Prisma.AccountUserUserIdFinancialAccountIdCompoundUniqueInput> =
  z
    .object({
      userId: z.string(),
      financialAccountId: z.string(),
    })
    .strict();

export const AccountUserCountOrderByAggregateInputSchema: z.ZodType<Prisma.AccountUserCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      autosign: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountUserAvgOrderByAggregateInputSchema: z.ZodType<Prisma.AccountUserAvgOrderByAggregateInput> =
  z
    .object({
      ownership: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountUserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AccountUserMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      autosign: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountUserMinOrderByAggregateInputSchema: z.ZodType<Prisma.AccountUserMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      autosign: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountUserSumOrderByAggregateInputSchema: z.ZodType<Prisma.AccountUserSumOrderByAggregateInput> =
  z
    .object({
      ownership: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumAccountUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.EnumAccountUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountUserRoleSchema).optional(),
      in: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => NestedEnumAccountUserRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountUserRoleFilterSchema).optional(),
    })
    .strict();

export const EnumJointAccountRequestStatusFilterSchema: z.ZodType<Prisma.EnumJointAccountRequestStatusFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      in: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(() => NestedEnumJointAccountRequestStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const UserNullableScalarRelationFilterSchema: z.ZodType<Prisma.UserNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => UserWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => UserWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const JointAccountRequestCountOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountRequestCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      recipientName: z.lazy(() => SortOrderSchema).optional(),
      recipientEmail: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      recipientId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      lastReminderAt: z.lazy(() => SortOrderSchema).optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountRequestAvgOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountRequestAvgOrderByAggregateInput> =
  z
    .object({
      ownership: z.lazy(() => SortOrderSchema).optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountRequestMaxOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountRequestMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      recipientName: z.lazy(() => SortOrderSchema).optional(),
      recipientEmail: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      recipientId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      lastReminderAt: z.lazy(() => SortOrderSchema).optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountRequestMinOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountRequestMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      recipientName: z.lazy(() => SortOrderSchema).optional(),
      recipientEmail: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      ownership: z.lazy(() => SortOrderSchema).optional(),
      recipientId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      lastReminderAt: z.lazy(() => SortOrderSchema).optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountRequestSumOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountRequestSumOrderByAggregateInput> =
  z
    .object({
      ownership: z.lazy(() => SortOrderSchema).optional(),
      reminderCount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumJointAccountRequestStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumJointAccountRequestStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      in: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => NestedEnumJointAccountRequestStatusWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumJointAccountRequestStatusFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumJointAccountRequestStatusFilterSchema)
        .optional(),
    })
    .strict();

export const EnumJointAccountModRequestTypeFilterSchema: z.ZodType<Prisma.EnumJointAccountModRequestTypeFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountModRequestTypeSchema).optional(),
      in: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(() => NestedEnumJointAccountModRequestTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionNullableScalarRelationFilterSchema: z.ZodType<Prisma.TransactionNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => TransactionWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => TransactionWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const JointAccountModRequestCountOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      transactionId: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountModRequestMaxOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      transactionId: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountModRequestMinOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      creatorId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      transactionId: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumJointAccountModRequestTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumJointAccountModRequestTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountModRequestTypeSchema).optional(),
      in: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              NestedEnumJointAccountModRequestTypeWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumJointAccountModRequestTypeFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumJointAccountModRequestTypeFilterSchema)
        .optional(),
    })
    .strict();

export const JointAccountModRequestScalarRelationFilterSchema: z.ZodType<Prisma.JointAccountModRequestScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
      isNot: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCountOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      jointAccountModRequestId: z.lazy(() => SortOrderSchema).optional(),
      approverId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalMaxOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      jointAccountModRequestId: z.lazy(() => SortOrderSchema).optional(),
      approverId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalMinOrderByAggregateInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      jointAccountModRequestId: z.lazy(() => SortOrderSchema).optional(),
      approverId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumInvestmentPlanCategoryFilterSchema: z.ZodType<Prisma.EnumInvestmentPlanCategoryFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentPlanCategorySchema).optional(),
      in: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(() => NestedEnumInvestmentPlanCategoryFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const EnumProfitDistributionFilterSchema: z.ZodType<Prisma.EnumProfitDistributionFilter> =
  z
    .object({
      equals: z.lazy(() => ProfitDistributionSchema).optional(),
      in: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => NestedEnumProfitDistributionFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanCountOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentPlanCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentPlanAvgOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentPlanAvgOrderByAggregateInput> =
  z
    .object({
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentPlanMaxOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentPlanMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentPlanMinOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentPlanMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentPlanSumOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentPlanSumOrderByAggregateInput> =
  z
    .object({
      minimumDeposit: z.lazy(() => SortOrderSchema).optional(),
      maximumDeposit: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      percentageTotalReturn: z.lazy(() => SortOrderSchema).optional(),
      percentagePeriodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumInvestmentPlanCategoryWithAggregatesFilterSchema: z.ZodType<Prisma.EnumInvestmentPlanCategoryWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentPlanCategorySchema).optional(),
      in: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => NestedEnumInvestmentPlanCategoryWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumInvestmentPlanCategoryFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumInvestmentPlanCategoryFilterSchema)
        .optional(),
    })
    .strict();

export const EnumProfitDistributionWithAggregatesFilterSchema: z.ZodType<Prisma.EnumProfitDistributionWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ProfitDistributionSchema).optional(),
      in: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => NestedEnumProfitDistributionWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumProfitDistributionFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumProfitDistributionFilterSchema).optional(),
    })
    .strict();

export const EnumInvestmentStatusFilterSchema: z.ZodType<Prisma.EnumInvestmentStatusFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentStatusSchema).optional(),
      in: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => NestedEnumInvestmentStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserScalarRelationFilterSchema: z.ZodType<Prisma.AccountUserScalarRelationFilter> =
  z
    .object({
      is: z.lazy(() => AccountUserWhereInputSchema).optional(),
      isNot: z.lazy(() => AccountUserWhereInputSchema).optional(),
    })
    .strict();

export const InvestmentCountOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      investorId: z.lazy(() => SortOrderSchema).optional(),
      deposit: z.lazy(() => SortOrderSchema).optional(),
      investmentName: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      pausedAt: z.lazy(() => SortOrderSchema).optional(),
      pausedReason: z.lazy(() => SortOrderSchema).optional(),
      closedAt: z.lazy(() => SortOrderSchema).optional(),
      closedReason: z.lazy(() => SortOrderSchema).optional(),
      terminatedAt: z.lazy(() => SortOrderSchema).optional(),
      terminatedReason: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentAvgOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentAvgOrderByAggregateInput> =
  z
    .object({
      deposit: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      investorId: z.lazy(() => SortOrderSchema).optional(),
      deposit: z.lazy(() => SortOrderSchema).optional(),
      investmentName: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      pausedAt: z.lazy(() => SortOrderSchema).optional(),
      pausedReason: z.lazy(() => SortOrderSchema).optional(),
      closedAt: z.lazy(() => SortOrderSchema).optional(),
      closedReason: z.lazy(() => SortOrderSchema).optional(),
      terminatedAt: z.lazy(() => SortOrderSchema).optional(),
      terminatedReason: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentMinOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      investorId: z.lazy(() => SortOrderSchema).optional(),
      deposit: z.lazy(() => SortOrderSchema).optional(),
      investmentName: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      pausedAt: z.lazy(() => SortOrderSchema).optional(),
      pausedReason: z.lazy(() => SortOrderSchema).optional(),
      closedAt: z.lazy(() => SortOrderSchema).optional(),
      closedReason: z.lazy(() => SortOrderSchema).optional(),
      terminatedAt: z.lazy(() => SortOrderSchema).optional(),
      terminatedReason: z.lazy(() => SortOrderSchema).optional(),
      category: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      profitDistribution: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const InvestmentSumOrderByAggregateInputSchema: z.ZodType<Prisma.InvestmentSumOrderByAggregateInput> =
  z
    .object({
      deposit: z.lazy(() => SortOrderSchema).optional(),
      totalProfit: z.lazy(() => SortOrderSchema).optional(),
      profitCount: z.lazy(() => SortOrderSchema).optional(),
      daysCompleted: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      totalReturn: z.lazy(() => SortOrderSchema).optional(),
      periodicReturn: z.lazy(() => SortOrderSchema).optional(),
      terminationFee: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumInvestmentStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumInvestmentStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentStatusSchema).optional(),
      in: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => NestedEnumInvestmentStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumInvestmentStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumInvestmentStatusFilterSchema).optional(),
    })
    .strict();

export const EnumTransactionTypeFilterSchema: z.ZodType<Prisma.EnumTransactionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionTypeSchema).optional(),
      in: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => NestedEnumTransactionTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const EnumTransactionStatusFilterSchema: z.ZodType<Prisma.EnumTransactionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionStatusSchema).optional(),
      in: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => NestedEnumTransactionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountNullableScalarRelationFilterSchema: z.ZodType<Prisma.FinancialAccountNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => FinancialAccountWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => FinancialAccountWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const InvestmentNullableScalarRelationFilterSchema: z.ZodType<Prisma.InvestmentNullableScalarRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => InvestmentWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => InvestmentWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const TransactionCountOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      initiatorAccountId: z.lazy(() => SortOrderSchema).optional(),
      recipientAccountId: z.lazy(() => SortOrderSchema).optional(),
      investmentId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      parentTransactionId: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      failedAt: z.lazy(() => SortOrderSchema).optional(),
      failReason: z.lazy(() => SortOrderSchema).optional(),
      depositWalletAddress: z.lazy(() => SortOrderSchema).optional(),
      depositWalletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      withdrawalWalletAddress: z.lazy(() => SortOrderSchema).optional(),
      withdrawalWalletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      bank: z.lazy(() => SortOrderSchema).optional(),
      bankAccount: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const TransactionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionAvgOrderByAggregateInput> =
  z
    .object({
      amount: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const TransactionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      initiatorAccountId: z.lazy(() => SortOrderSchema).optional(),
      recipientAccountId: z.lazy(() => SortOrderSchema).optional(),
      investmentId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      parentTransactionId: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      failedAt: z.lazy(() => SortOrderSchema).optional(),
      failReason: z.lazy(() => SortOrderSchema).optional(),
      depositWalletAddress: z.lazy(() => SortOrderSchema).optional(),
      depositWalletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      withdrawalWalletAddress: z.lazy(() => SortOrderSchema).optional(),
      withdrawalWalletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      bank: z.lazy(() => SortOrderSchema).optional(),
      bankAccount: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const TransactionMinOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      initiatorAccountId: z.lazy(() => SortOrderSchema).optional(),
      recipientAccountId: z.lazy(() => SortOrderSchema).optional(),
      investmentId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      parentTransactionId: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      failedAt: z.lazy(() => SortOrderSchema).optional(),
      failReason: z.lazy(() => SortOrderSchema).optional(),
      depositWalletAddress: z.lazy(() => SortOrderSchema).optional(),
      depositWalletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      withdrawalWalletAddress: z.lazy(() => SortOrderSchema).optional(),
      withdrawalWalletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      bank: z.lazy(() => SortOrderSchema).optional(),
      bankAccount: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const TransactionSumOrderByAggregateInputSchema: z.ZodType<Prisma.TransactionSumOrderByAggregateInput> =
  z
    .object({
      amount: z.lazy(() => SortOrderSchema).optional(),
      USDAmount: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      charges: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumTransactionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumTransactionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionTypeSchema).optional(),
      in: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => NestedEnumTransactionTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumTransactionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumTransactionTypeFilterSchema).optional(),
    })
    .strict();

export const EnumTransactionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumTransactionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionStatusSchema).optional(),
      in: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => NestedEnumTransactionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional(),
    })
    .strict();

export const EnumNotificationBodyTypeFilterSchema: z.ZodType<Prisma.EnumNotificationBodyTypeFilter> =
  z
    .object({
      equals: z.lazy(() => NotificationBodyTypeSchema).optional(),
      in: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(() => NestedEnumNotificationBodyTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationCountOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      bodyType: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      link: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const NotificationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      bodyType: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      link: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const NotificationMinOrderByAggregateInputSchema: z.ZodType<Prisma.NotificationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      body: z.lazy(() => SortOrderSchema).optional(),
      bodyType: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      financialAccountId: z.lazy(() => SortOrderSchema).optional(),
      link: z.lazy(() => SortOrderSchema).optional(),
      isRead: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumNotificationBodyTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumNotificationBodyTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => NotificationBodyTypeSchema).optional(),
      in: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => NestedEnumNotificationBodyTypeWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumNotificationBodyTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumNotificationBodyTypeFilterSchema).optional(),
    })
    .strict();

export const CurrencyCountOrderByAggregateInputSchema: z.ZodType<Prisma.CurrencyCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      symbol: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      rateUpdatedAt: z.lazy(() => SortOrderSchema).optional(),
      walletAddress: z.lazy(() => SortOrderSchema).optional(),
      walletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawal: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CurrencyAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CurrencyAvgOrderByAggregateInput> =
  z
    .object({
      rate: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CurrencyMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CurrencyMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      symbol: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      rateUpdatedAt: z.lazy(() => SortOrderSchema).optional(),
      walletAddress: z.lazy(() => SortOrderSchema).optional(),
      walletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawal: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CurrencyMinOrderByAggregateInputSchema: z.ZodType<Prisma.CurrencyMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      symbol: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      rate: z.lazy(() => SortOrderSchema).optional(),
      rateUpdatedAt: z.lazy(() => SortOrderSchema).optional(),
      walletAddress: z.lazy(() => SortOrderSchema).optional(),
      walletAddressNetwork: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawal: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CurrencySumOrderByAggregateInputSchema: z.ZodType<Prisma.CurrencySumOrderByAggregateInput> =
  z
    .object({
      rate: z.lazy(() => SortOrderSchema).optional(),
      withdrawalCharge: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SettingsCountOrderByAggregateInputSchema: z.ZodType<Prisma.SettingsCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawals: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SettingsMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SettingsMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawals: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SettingsMinOrderByAggregateInputSchema: z.ZodType<Prisma.SettingsMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      allowWithdrawals: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ProfileCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProfileCreateWithoutUserInputSchema),
          z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProfileCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SessionCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountCreateNestedManyWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedManyWithoutCreatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema),
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema).array(),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => FinancialAccountCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUserCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutUserInputSchema),
          z.lazy(() => AccountUserCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestCreateNestedManyWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestCreateNestedManyWithoutCreatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestCreateNestedManyWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestCreateNestedManyWithoutRecipientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyRecipientInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateNestedManyWithoutCreatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateNestedManyWithoutApproverInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyApproverInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const ProfileUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProfileCreateWithoutUserInputSchema),
          z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProfileCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SessionUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateNestedManyWithoutCreatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema),
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema).array(),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => FinancialAccountCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutUserInputSchema),
          z.lazy(() => AccountUserCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyRecipientInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyApproverInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const StringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.StringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional(),
    })
    .strict();

export const BoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.BoolFieldUpdateOperationsInput> =
  z
    .object({
      set: z.boolean().optional(),
    })
    .strict();

export const NullableStringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional().nullable(),
    })
    .strict();

export const EnumUserRoleFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumUserRoleFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => UserRoleSchema).optional(),
    })
    .strict();

export const NullableBoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableBoolFieldUpdateOperationsInput> =
  z
    .object({
      set: z.boolean().optional().nullable(),
    })
    .strict();

export const NullableDateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional().nullable(),
    })
    .strict();

export const DateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional(),
    })
    .strict();

export const ProfileUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.ProfileUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProfileCreateWithoutUserInputSchema),
          z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProfileCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => ProfileUpsertWithoutUserInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => ProfileWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => ProfileWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ProfileUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => ProfileUpdateWithoutUserInputSchema),
          z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SessionUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateManyWithoutCreatorNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateManyWithoutCreatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema),
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema).array(),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpsertWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                FinancialAccountUpsertWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => FinancialAccountCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                FinancialAccountUpdateWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => FinancialAccountUpdateManyWithWhereWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                FinancialAccountUpdateManyWithWhereWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FinancialAccountScalarWhereInputSchema),
          z.lazy(() => FinancialAccountScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUserUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutUserInputSchema),
          z.lazy(() => AccountUserCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUserUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUserUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUserUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountUserScalarWhereInputSchema),
          z.lazy(() => AccountUserScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyWithoutCreatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateManyWithWhereWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateManyWithWhereWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyWithoutRecipientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpsertWithWhereUniqueWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpsertWithWhereUniqueWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyRecipientInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateWithWhereUniqueWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateWithWhereUniqueWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateManyWithWhereWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateManyWithWhereWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyWithoutCreatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateManyWithWhereWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateManyWithWhereWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyApproverInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateManyWithWhereWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateManyWithWhereWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const ProfileUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ProfileCreateWithoutUserInputSchema),
          z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ProfileCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => ProfileUpsertWithoutUserInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => ProfileWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => ProfileWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => ProfileWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ProfileUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => ProfileUpdateWithoutUserInputSchema),
          z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SessionCreateWithoutUserInputSchema),
          z.lazy(() => SessionCreateWithoutUserInputSchema).array(),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => SessionCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => SessionCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SessionWhereUniqueInputSchema),
          z.lazy(() => SessionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => SessionUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => SessionUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema),
          z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema).array(),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => FinancialAccountCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpsertWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                FinancialAccountUpsertWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => FinancialAccountCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => FinancialAccountWhereUniqueInputSchema),
          z.lazy(() => FinancialAccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                FinancialAccountUpdateWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => FinancialAccountUpdateManyWithWhereWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                FinancialAccountUpdateManyWithWhereWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => FinancialAccountScalarWhereInputSchema),
          z.lazy(() => FinancialAccountScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutUserInputSchema),
          z.lazy(() => AccountUserCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => AccountUserCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUserUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUserUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUserUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => AccountUserUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountUserScalarWhereInputSchema),
          z.lazy(() => AccountUserScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateManyWithWhereWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateManyWithWhereWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema),
          z
            .lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema)
            .array(),
          z.lazy(
            () => JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpsertWithWhereUniqueWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpsertWithWhereUniqueWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountRequestCreateManyRecipientInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateWithWhereUniqueWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateWithWhereUniqueWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateManyWithWhereWithoutRecipientInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateManyWithWhereWithoutRecipientInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpsertWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyCreatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateWithWhereUniqueWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateManyWithWhereWithoutCreatorInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateManyWithWhereWithoutCreatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutUserInputSchema),
          z.lazy(() => NotificationCreateWithoutUserInputSchema).array(),
          z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
          z
            .lazy(() => NotificationUncheckedCreateWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => NotificationCreateOrConnectWithoutUserInputSchema),
          z
            .lazy(() => NotificationCreateOrConnectWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpsertWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyUserInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateWithWhereUniqueWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema),
          z
            .lazy(() => NotificationUpdateManyWithWhereWithoutUserInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyApproverInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateManyWithWhereWithoutApproverInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateManyWithWhereWithoutApproverInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSessionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSessionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSessionsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutSessionsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSessionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSessionsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSessionsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutSessionsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutSessionsInputSchema),
          z.lazy(() => UserUpdateWithoutSessionsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAccountsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAccountsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutAccountsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAccountsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAccountsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutAccountsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAccountsInputSchema),
          z.lazy(() => UserUpdateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutProfileInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutProfileInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutProfileInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutProfileInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumGovernmentIdTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const NullableEnumKycStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumKycStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutProfileNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutProfileNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutProfileInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutProfileInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutProfileInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutProfileInputSchema),
          z.lazy(() => UserUpdateWithoutProfileInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutProfileInputSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutBusinessProfileInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutBusinessProfileInputSchema),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutBusinessProfileInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutBusinessProfileInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const NullableIntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional().nullable(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict();

export const FinancialAccountUpdateOneRequiredWithoutBusinessProfileNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneRequiredWithoutBusinessProfileNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutBusinessProfileInputSchema),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutBusinessProfileInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutBusinessProfileInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => FinancialAccountUpsertWithoutBusinessProfileInputSchema)
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutBusinessProfileInputSchema,
          ),
          z.lazy(() => FinancialAccountUpdateWithoutBusinessProfileInputSchema),
          z.lazy(
            () =>
              FinancialAccountUncheckedUpdateWithoutBusinessProfileInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCreatedAccountsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCreatedAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCreatedAccountsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCreatedAccountsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BusinessProfileCreateNestedOneWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileCreateNestedOneWithoutAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BusinessProfileCreateWithoutAccountInputSchema),
          z.lazy(() => BusinessProfileUncheckedCreateWithoutAccountInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BusinessProfileCreateOrConnectWithoutAccountInputSchema)
        .optional(),
      connect: z.lazy(() => BusinessProfileWhereUniqueInputSchema).optional(),
    })
    .strict();

export const AccountUserCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountRequestCreateManyFinancialAccountInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateNestedManyWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateNestedManyWithoutAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => NotificationCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionCreateNestedManyWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionCreateNestedManyWithoutRecipientAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutRecipientAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutRecipientAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyRecipientAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedCreateNestedOneWithoutAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BusinessProfileCreateWithoutAccountInputSchema),
          z.lazy(() => BusinessProfileUncheckedCreateWithoutAccountInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BusinessProfileCreateOrConnectWithoutAccountInputSchema)
        .optional(),
      connect: z.lazy(() => BusinessProfileWhereUniqueInputSchema).optional(),
    })
    .strict();

export const AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountRequestCreateManyFinancialAccountInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => NotificationCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateNestedManyWithoutRecipientAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutRecipientAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutRecipientAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyRecipientAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumAccountStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumAccountStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => AccountStatusSchema).optional(),
    })
    .strict();

export const EnumAccountTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumAccountTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => AccountTypeSchema).optional(),
    })
    .strict();

export const EnumAccountOwnershipFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumAccountOwnershipFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => AccountOwnershipSchema).optional(),
    })
    .strict();

export const FloatFieldUpdateOperationsInputSchema: z.ZodType<Prisma.FloatFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict();

export const IntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.IntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCreatedAccountsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCreatedAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCreatedAccountsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCreatedAccountsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutCreatedAccountsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => UserUpdateToOneWithWhereWithoutCreatedAccountsInputSchema,
          ),
          z.lazy(() => UserUpdateWithoutCreatedAccountsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutCreatedAccountsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileUpdateOneWithoutAccountNestedInputSchema: z.ZodType<Prisma.BusinessProfileUpdateOneWithoutAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BusinessProfileCreateWithoutAccountInputSchema),
          z.lazy(() => BusinessProfileUncheckedCreateWithoutAccountInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BusinessProfileCreateOrConnectWithoutAccountInputSchema)
        .optional(),
      upsert: z
        .lazy(() => BusinessProfileUpsertWithoutAccountInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => BusinessProfileWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => BusinessProfileWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => BusinessProfileWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => BusinessProfileUpdateToOneWithWhereWithoutAccountInputSchema,
          ),
          z.lazy(() => BusinessProfileUpdateWithoutAccountInputSchema),
          z.lazy(() => BusinessProfileUncheckedUpdateWithoutAccountInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.AccountUserUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              AccountUserUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              AccountUserUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              AccountUserUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountUserScalarWhereInputSchema),
          z.lazy(() => AccountUserScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountRequestCreateManyFinancialAccountInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyWithoutAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpsertWithWhereUniqueWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpsertWithWhereUniqueWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateWithWhereUniqueWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateWithWhereUniqueWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateManyWithWhereWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateManyWithWhereWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => NotificationCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              NotificationUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              NotificationUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              NotificationUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              TransactionUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateManyWithoutRecipientAccountNestedInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithoutRecipientAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutRecipientAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutRecipientAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              TransactionUpsertWithWhereUniqueWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyRecipientAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateWithWhereUniqueWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateManyWithWhereWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateManyWithWhereWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.InvestmentUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              InvestmentUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                InvestmentUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              InvestmentUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                InvestmentUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              InvestmentUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                InvestmentUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InvestmentScalarWhereInputSchema),
          z.lazy(() => InvestmentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedUpdateOneWithoutAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BusinessProfileCreateWithoutAccountInputSchema),
          z.lazy(() => BusinessProfileUncheckedCreateWithoutAccountInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BusinessProfileCreateOrConnectWithoutAccountInputSchema)
        .optional(),
      upsert: z
        .lazy(() => BusinessProfileUpsertWithoutAccountInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => BusinessProfileWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => BusinessProfileWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => BusinessProfileWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => BusinessProfileUpdateToOneWithWhereWithoutAccountInputSchema,
          ),
          z.lazy(() => BusinessProfileUpdateWithoutAccountInputSchema),
          z.lazy(() => BusinessProfileUncheckedUpdateWithoutAccountInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              AccountUserUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AccountUserCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountUserWhereUniqueInputSchema),
          z.lazy(() => AccountUserWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              AccountUserUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              AccountUserUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                AccountUserUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountUserScalarWhereInputSchema),
          z.lazy(() => AccountUserScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountRequestCreateManyFinancialAccountInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountRequestUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountRequestUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema),
          z
            .lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema)
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpsertWithWhereUniqueWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpsertWithWhereUniqueWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => JointAccountModRequestCreateManyAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateWithWhereUniqueWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateWithWhereUniqueWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateManyWithWhereWithoutAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateManyWithWhereWithoutAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => NotificationCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => NotificationCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              NotificationUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => NotificationCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => NotificationWhereUniqueInputSchema),
          z.lazy(() => NotificationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              NotificationUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              NotificationUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                NotificationUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              TransactionUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutRecipientAccountInputSchema),
          z
            .lazy(() => TransactionCreateWithoutRecipientAccountInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              TransactionUpsertWithWhereUniqueWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyRecipientAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateWithWhereUniqueWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateManyWithWhereWithoutRecipientAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateManyWithWhereWithoutRecipientAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema),
          z
            .lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema)
            .array(),
          z.lazy(
            () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () => InvestmentCreateOrConnectWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              InvestmentUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                InvestmentUpsertWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyFinancialAccountInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              InvestmentUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                InvestmentUpdateWithWhereUniqueWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              InvestmentUpdateManyWithWhereWithoutFinancialAccountInputSchema,
          ),
          z
            .lazy(
              () =>
                InvestmentUpdateManyWithWhereWithoutFinancialAccountInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InvestmentScalarWhereInputSchema),
          z.lazy(() => InvestmentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAccountMembershipsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountMembershipsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountMembershipsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAccountMembershipsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutAccountUsersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutAccountUsersInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutAccountUsersInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutAccountUsersInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const TransactionCreateNestedManyWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionCreateNestedManyWithoutInitiatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema),
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInitiatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentCreateNestedManyWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentCreateNestedManyWithoutInvestorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema),
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema).array(),
          z.lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyInvestorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateNestedManyWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateNestedManyWithoutInitiatorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema),
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInitiatorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUncheckedCreateNestedManyWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUncheckedCreateNestedManyWithoutInvestorInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema),
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema).array(),
          z.lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyInvestorInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumAccountUserRoleFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumAccountUserRoleFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => AccountUserRoleSchema).optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutAccountMembershipsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAccountMembershipsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountMembershipsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountMembershipsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAccountMembershipsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutAccountMembershipsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => UserUpdateToOneWithWhereWithoutAccountMembershipsInputSchema,
          ),
          z.lazy(() => UserUpdateWithoutAccountMembershipsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAccountMembershipsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneRequiredWithoutAccountUsersNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneRequiredWithoutAccountUsersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutAccountUsersInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutAccountUsersInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutAccountUsersInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => FinancialAccountUpsertWithoutAccountUsersInputSchema)
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutAccountUsersInputSchema,
          ),
          z.lazy(() => FinancialAccountUpdateWithoutAccountUsersInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedUpdateWithoutAccountUsersInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateManyWithoutInitiatorNestedInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithoutInitiatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema),
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => TransactionUpsertWithWhereUniqueWithoutInitiatorInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpsertWithWhereUniqueWithoutInitiatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInitiatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => TransactionUpdateWithWhereUniqueWithoutInitiatorInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpdateWithWhereUniqueWithoutInitiatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => TransactionUpdateManyWithWhereWithoutInitiatorInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpdateManyWithWhereWithoutInitiatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUpdateManyWithoutInvestorNestedInputSchema: z.ZodType<Prisma.InvestmentUpdateManyWithoutInvestorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema),
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema).array(),
          z.lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => InvestmentUpsertWithWhereUniqueWithoutInvestorInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUpsertWithWhereUniqueWithoutInvestorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyInvestorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => InvestmentUpdateWithWhereUniqueWithoutInvestorInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUpdateWithWhereUniqueWithoutInvestorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => InvestmentUpdateManyWithWhereWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentUpdateManyWithWhereWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InvestmentScalarWhereInputSchema),
          z.lazy(() => InvestmentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutInitiatorNestedInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutInitiatorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema),
          z.lazy(() => TransactionCreateWithoutInitiatorInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInitiatorInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => TransactionUpsertWithWhereUniqueWithoutInitiatorInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpsertWithWhereUniqueWithoutInitiatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInitiatorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => TransactionUpdateWithWhereUniqueWithoutInitiatorInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpdateWithWhereUniqueWithoutInitiatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => TransactionUpdateManyWithWhereWithoutInitiatorInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpdateManyWithWhereWithoutInitiatorInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateManyWithoutInvestorNestedInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateManyWithoutInvestorNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema),
          z.lazy(() => InvestmentCreateWithoutInvestorInputSchema).array(),
          z.lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentCreateOrConnectWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => InvestmentUpsertWithWhereUniqueWithoutInvestorInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUpsertWithWhereUniqueWithoutInvestorInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => InvestmentCreateManyInvestorInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => InvestmentWhereUniqueInputSchema),
          z.lazy(() => InvestmentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => InvestmentUpdateWithWhereUniqueWithoutInvestorInputSchema,
          ),
          z
            .lazy(
              () => InvestmentUpdateWithWhereUniqueWithoutInvestorInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => InvestmentUpdateManyWithWhereWithoutInvestorInputSchema),
          z
            .lazy(() => InvestmentUpdateManyWithWhereWithoutInvestorInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => InvestmentScalarWhereInputSchema),
          z.lazy(() => InvestmentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCreatedJointAccountRequestsInputSchema),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutCreatedJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutCreatedJointAccountRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => UserCreateWithoutReceivedJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutReceivedJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutReceivedJointAccountRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutJointAccountRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => FinancialAccountCreateWithoutJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutJointAccountRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumJointAccountRequestStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => JointAccountRequestStatusSchema).optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutCreatedJointAccountRequestsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCreatedJointAccountRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCreatedJointAccountRequestsInputSchema),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutCreatedJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutCreatedJointAccountRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutCreatedJointAccountRequestsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              UserUpdateToOneWithWhereWithoutCreatedJointAccountRequestsInputSchema,
          ),
          z.lazy(() => UserUpdateWithoutCreatedJointAccountRequestsInputSchema),
          z.lazy(
            () =>
              UserUncheckedUpdateWithoutCreatedJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutReceivedJointAccountRequestsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutReceivedJointAccountRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => UserCreateWithoutReceivedJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutReceivedJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutReceivedJointAccountRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutReceivedJointAccountRequestsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              UserUpdateToOneWithWhereWithoutReceivedJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () => UserUpdateWithoutReceivedJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedUpdateWithoutReceivedJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneRequiredWithoutJointAccountRequestsNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneRequiredWithoutJointAccountRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => FinancialAccountCreateWithoutJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutJointAccountRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(
          () => FinancialAccountUpsertWithoutJointAccountRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () => FinancialAccountUpdateWithoutJointAccountRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedUpdateWithoutJointAccountRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => UserCreateWithoutCreatedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutCreatedJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutCreatedJointAccountModRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutJointAccountModRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () =>
              FinancialAccountCreateWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const TransactionCreateNestedOneWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionCreateNestedOneWithoutJointAccountModRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => TransactionCreateWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              TransactionUncheckedCreateWithoutJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            TransactionCreateOrConnectWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => TransactionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateNestedManyWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateNestedManyWithoutRequestInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyRequestInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutRequestInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyRequestInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumJointAccountModRequestTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => JointAccountModRequestTypeSchema).optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutCreatedJointAccountModRequestsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCreatedJointAccountModRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => UserCreateWithoutCreatedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutCreatedJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutCreatedJointAccountModRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutCreatedJointAccountModRequestsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              UserUpdateToOneWithWhereWithoutCreatedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () => UserUpdateWithoutCreatedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedUpdateWithoutCreatedJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneRequiredWithoutJointAccountModRequestsNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneRequiredWithoutJointAccountModRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () =>
              FinancialAccountCreateWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(
          () => FinancialAccountUpsertWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUpdateWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedUpdateWithoutJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateOneWithoutJointAccountModRequestsNestedInputSchema: z.ZodType<Prisma.TransactionUpdateOneWithoutJointAccountModRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => TransactionCreateWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              TransactionUncheckedCreateWithoutJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            TransactionCreateOrConnectWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => TransactionUpsertWithoutJointAccountModRequestsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => TransactionWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => TransactionWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => TransactionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateToOneWithWhereWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () => TransactionUpdateWithoutJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              TransactionUncheckedUpdateWithoutJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyWithoutRequestNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyWithoutRequestNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyRequestInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateManyWithWhereWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateManyWithWhereWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateManyRequestInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema)
            .array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestApprovalUpdateManyWithWhereWithoutRequestInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestApprovalUpdateManyWithWhereWithoutRequestInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
            .array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateNestedOneWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateNestedOneWithoutApprovalsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutApprovalsInputSchema),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutApprovalsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            JointAccountModRequestCreateOrConnectWithoutApprovalsInputSchema,
        )
        .optional(),
      connect: z
        .lazy(() => JointAccountModRequestWhereUniqueInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => UserCreateWithoutApprovedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutApprovedJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutApprovedJointAccountModRequestsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestUpdateOneRequiredWithoutApprovalsNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateOneRequiredWithoutApprovalsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => JointAccountModRequestCreateWithoutApprovalsInputSchema),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutApprovalsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            JointAccountModRequestCreateOrConnectWithoutApprovalsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => JointAccountModRequestUpsertWithoutApprovalsInputSchema)
        .optional(),
      connect: z
        .lazy(() => JointAccountModRequestWhereUniqueInputSchema)
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateToOneWithWhereWithoutApprovalsInputSchema,
          ),
          z.lazy(() => JointAccountModRequestUpdateWithoutApprovalsInputSchema),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedUpdateWithoutApprovalsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutApprovedJointAccountModRequestsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutApprovedJointAccountModRequestsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => UserCreateWithoutApprovedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedCreateWithoutApprovedJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            UserCreateOrConnectWithoutApprovedJointAccountModRequestsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutApprovedJointAccountModRequestsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              UserUpdateToOneWithWhereWithoutApprovedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () => UserUpdateWithoutApprovedJointAccountModRequestsInputSchema,
          ),
          z.lazy(
            () =>
              UserUncheckedUpdateWithoutApprovedJointAccountModRequestsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumInvestmentPlanCategoryFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => InvestmentPlanCategorySchema).optional(),
    })
    .strict();

export const EnumProfitDistributionFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumProfitDistributionFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ProfitDistributionSchema).optional(),
    })
    .strict();

export const AccountUserCreateNestedOneWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserCreateNestedOneWithoutInvestmentsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutInvestmentsInputSchema),
          z.lazy(() => AccountUserUncheckedCreateWithoutInvestmentsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => AccountUserCreateOrConnectWithoutInvestmentsInputSchema)
        .optional(),
      connect: z.lazy(() => AccountUserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const TransactionCreateNestedManyWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionCreateNestedManyWithoutInvestmentInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema),
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInvestmentInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutInvestmentsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutInvestmentsInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutInvestmentsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutInvestmentsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const TransactionUncheckedCreateNestedManyWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateNestedManyWithoutInvestmentInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema),
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInvestmentInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumInvestmentStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumInvestmentStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => InvestmentStatusSchema).optional(),
    })
    .strict();

export const AccountUserUpdateOneRequiredWithoutInvestmentsNestedInputSchema: z.ZodType<Prisma.AccountUserUpdateOneRequiredWithoutInvestmentsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutInvestmentsInputSchema),
          z.lazy(() => AccountUserUncheckedCreateWithoutInvestmentsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => AccountUserCreateOrConnectWithoutInvestmentsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => AccountUserUpsertWithoutInvestmentsInputSchema)
        .optional(),
      connect: z.lazy(() => AccountUserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => AccountUserUpdateToOneWithWhereWithoutInvestmentsInputSchema,
          ),
          z.lazy(() => AccountUserUpdateWithoutInvestmentsInputSchema),
          z.lazy(() => AccountUserUncheckedUpdateWithoutInvestmentsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateManyWithoutInvestmentNestedInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithoutInvestmentNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema),
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => TransactionUpsertWithWhereUniqueWithoutInvestmentInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutInvestmentInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInvestmentInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => TransactionUpdateWithWhereUniqueWithoutInvestmentInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutInvestmentInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => TransactionUpdateManyWithWhereWithoutInvestmentInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpdateManyWithWhereWithoutInvestmentInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneRequiredWithoutInvestmentsNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneRequiredWithoutInvestmentsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutInvestmentsInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutInvestmentsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutInvestmentsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => FinancialAccountUpsertWithoutInvestmentsInputSchema)
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutInvestmentsInputSchema,
          ),
          z.lazy(() => FinancialAccountUpdateWithoutInvestmentsInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedUpdateWithoutInvestmentsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutInvestmentNestedInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutInvestmentNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema),
          z.lazy(() => TransactionCreateWithoutInvestmentInputSchema).array(),
          z.lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema),
          z
            .lazy(() => TransactionCreateOrConnectWithoutInvestmentInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => TransactionUpsertWithWhereUniqueWithoutInvestmentInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutInvestmentInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyInvestmentInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => TransactionUpdateWithWhereUniqueWithoutInvestmentInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutInvestmentInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => TransactionUpdateManyWithWhereWithoutInvestmentInputSchema,
          ),
          z
            .lazy(
              () => TransactionUpdateManyWithWhereWithoutInvestmentInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserCreateNestedOneWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserCreateNestedOneWithoutTransactionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutTransactionsInputSchema),
          z.lazy(
            () => AccountUserUncheckedCreateWithoutTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => AccountUserCreateOrConnectWithoutTransactionsInputSchema)
        .optional(),
      connect: z.lazy(() => AccountUserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutTransactionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutTransactionsInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutTransactionsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutReceivedTransactionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => FinancialAccountCreateWithoutReceivedTransactionsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutReceivedTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const InvestmentCreateNestedOneWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentCreateNestedOneWithoutTransactionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutTransactionsInputSchema),
          z.lazy(() => InvestmentUncheckedCreateWithoutTransactionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => InvestmentCreateOrConnectWithoutTransactionsInputSchema)
        .optional(),
      connect: z.lazy(() => InvestmentWhereUniqueInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateNestedManyWithoutTransactionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () => JointAccountModRequestCreateWithoutTransactionInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () => JointAccountModRequestCreateManyTransactionInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionCreateNestedOneWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionCreateNestedOneWithoutChildTransactionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutChildTransactionsInputSchema),
          z.lazy(
            () => TransactionUncheckedCreateWithoutChildTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => TransactionCreateOrConnectWithoutChildTransactionsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => TransactionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const TransactionCreateNestedManyWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionCreateNestedManyWithoutParentTransactionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutParentTransactionInputSchema),
          z
            .lazy(() => TransactionCreateWithoutParentTransactionInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyParentTransactionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () => JointAccountModRequestCreateWithoutTransactionInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () => JointAccountModRequestCreateManyTransactionInputEnvelopeSchema,
        )
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateNestedManyWithoutParentTransactionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutParentTransactionInputSchema),
          z
            .lazy(() => TransactionCreateWithoutParentTransactionInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyParentTransactionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumTransactionTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumTransactionTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => TransactionTypeSchema).optional(),
    })
    .strict();

export const EnumTransactionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumTransactionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => TransactionStatusSchema).optional(),
    })
    .strict();

export const AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema: z.ZodType<Prisma.AccountUserUpdateOneRequiredWithoutTransactionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountUserCreateWithoutTransactionsInputSchema),
          z.lazy(
            () => AccountUserUncheckedCreateWithoutTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => AccountUserCreateOrConnectWithoutTransactionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => AccountUserUpsertWithoutTransactionsInputSchema)
        .optional(),
      connect: z.lazy(() => AccountUserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => AccountUserUpdateToOneWithWhereWithoutTransactionsInputSchema,
          ),
          z.lazy(() => AccountUserUpdateWithoutTransactionsInputSchema),
          z.lazy(
            () => AccountUserUncheckedUpdateWithoutTransactionsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutTransactionsInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedCreateWithoutTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutTransactionsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => FinancialAccountUpsertWithoutTransactionsInputSchema)
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutTransactionsInputSchema,
          ),
          z.lazy(() => FinancialAccountUpdateWithoutTransactionsInputSchema),
          z.lazy(
            () => FinancialAccountUncheckedUpdateWithoutTransactionsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => FinancialAccountCreateWithoutReceivedTransactionsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutReceivedTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () =>
            FinancialAccountCreateOrConnectWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(
          () => FinancialAccountUpsertWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => FinancialAccountWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => FinancialAccountWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutReceivedTransactionsInputSchema,
          ),
          z.lazy(
            () => FinancialAccountUpdateWithoutReceivedTransactionsInputSchema,
          ),
          z.lazy(
            () =>
              FinancialAccountUncheckedUpdateWithoutReceivedTransactionsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUpdateOneWithoutTransactionsNestedInputSchema: z.ZodType<Prisma.InvestmentUpdateOneWithoutTransactionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => InvestmentCreateWithoutTransactionsInputSchema),
          z.lazy(() => InvestmentUncheckedCreateWithoutTransactionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => InvestmentCreateOrConnectWithoutTransactionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => InvestmentUpsertWithoutTransactionsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => InvestmentWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => InvestmentWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => InvestmentWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => InvestmentUpdateToOneWithWhereWithoutTransactionsInputSchema,
          ),
          z.lazy(() => InvestmentUpdateWithoutTransactionsInputSchema),
          z.lazy(() => InvestmentUncheckedUpdateWithoutTransactionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyWithoutTransactionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () => JointAccountModRequestCreateWithoutTransactionInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpsertWithWhereUniqueWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpsertWithWhereUniqueWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () => JointAccountModRequestCreateManyTransactionInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateWithWhereUniqueWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateWithWhereUniqueWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateManyWithWhereWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateManyWithWhereWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateOneWithoutChildTransactionsNestedInputSchema: z.ZodType<Prisma.TransactionUpdateOneWithoutChildTransactionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutChildTransactionsInputSchema),
          z.lazy(
            () => TransactionUncheckedCreateWithoutChildTransactionsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => TransactionCreateOrConnectWithoutChildTransactionsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => TransactionUpsertWithoutChildTransactionsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => TransactionWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => TransactionWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => TransactionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateToOneWithWhereWithoutChildTransactionsInputSchema,
          ),
          z.lazy(() => TransactionUpdateWithoutChildTransactionsInputSchema),
          z.lazy(
            () => TransactionUncheckedUpdateWithoutChildTransactionsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateManyWithoutParentTransactionNestedInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithoutParentTransactionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutParentTransactionInputSchema),
          z
            .lazy(() => TransactionCreateWithoutParentTransactionInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              TransactionUpsertWithWhereUniqueWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyParentTransactionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateWithWhereUniqueWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateManyWithWhereWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateManyWithWhereWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(
            () => JointAccountModRequestCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () => JointAccountModRequestCreateWithoutTransactionInputSchema,
            )
            .array(),
          z.lazy(
            () =>
              JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpsertWithWhereUniqueWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpsertWithWhereUniqueWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(
          () => JointAccountModRequestCreateManyTransactionInputEnvelopeSchema,
        )
        .optional(),
      set: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
          z.lazy(() => JointAccountModRequestWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateWithWhereUniqueWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateWithWhereUniqueWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              JointAccountModRequestUpdateManyWithWhereWithoutTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                JointAccountModRequestUpdateManyWithWhereWithoutTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutParentTransactionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => TransactionCreateWithoutParentTransactionInputSchema),
          z
            .lazy(() => TransactionCreateWithoutParentTransactionInputSchema)
            .array(),
          z.lazy(
            () => TransactionUncheckedCreateWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUncheckedCreateWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => TransactionCreateOrConnectWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionCreateOrConnectWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              TransactionUpsertWithWhereUniqueWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpsertWithWhereUniqueWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => TransactionCreateManyParentTransactionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => TransactionWhereUniqueInputSchema),
          z.lazy(() => TransactionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateWithWhereUniqueWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateWithWhereUniqueWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              TransactionUpdateManyWithWhereWithoutParentTransactionInputSchema,
          ),
          z
            .lazy(
              () =>
                TransactionUpdateManyWithWhereWithoutParentTransactionInputSchema,
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutNotificationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNotificationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutNotificationsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const FinancialAccountCreateNestedOneWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountCreateNestedOneWithoutNotificationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutNotificationsInputSchema),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutNotificationsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutNotificationsInputSchema,
        )
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumNotificationBodyTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumNotificationBodyTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => NotificationBodyTypeSchema).optional(),
    })
    .strict();

export const UserUpdateOneWithoutNotificationsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutNotificationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutNotificationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutNotificationsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => UserUpsertWithoutNotificationsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutNotificationsInputSchema),
          z.lazy(() => UserUpdateWithoutNotificationsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateOneWithoutNotificationsNestedInputSchema: z.ZodType<Prisma.FinancialAccountUpdateOneWithoutNotificationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => FinancialAccountCreateWithoutNotificationsInputSchema),
          z.lazy(
            () =>
              FinancialAccountUncheckedCreateWithoutNotificationsInputSchema,
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(
          () => FinancialAccountCreateOrConnectWithoutNotificationsInputSchema,
        )
        .optional(),
      upsert: z
        .lazy(() => FinancialAccountUpsertWithoutNotificationsInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => FinancialAccountWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => FinancialAccountWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => FinancialAccountWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () =>
              FinancialAccountUpdateToOneWithWhereWithoutNotificationsInputSchema,
          ),
          z.lazy(() => FinancialAccountUpdateWithoutNotificationsInputSchema),
          z.lazy(
            () =>
              FinancialAccountUncheckedUpdateWithoutNotificationsInputSchema,
          ),
        ])
        .optional(),
    })
    .strict();

export const NestedStringFilterSchema: z.ZodType<Prisma.NestedStringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringFilterSchema)])
      .optional(),
  })
  .strict();

export const NestedBoolFilterSchema: z.ZodType<Prisma.NestedBoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z
      .union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)])
      .optional(),
  })
  .strict();

export const NestedStringNullableFilterSchema: z.ZodType<Prisma.NestedStringNullableFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumUserRoleFilterSchema: z.ZodType<Prisma.NestedEnumUserRoleFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedBoolNullableFilterSchema: z.ZodType<Prisma.NestedBoolNullableFilter> =
  z
    .object({
      equals: z.boolean().optional().nullable(),
      not: z
        .union([z.boolean(), z.lazy(() => NestedBoolNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedDateTimeNullableFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedDateTimeFilterSchema: z.ZodType<Prisma.NestedDateTimeFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)])
        .optional(),
    })
    .strict();

export const NestedStringWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional(),
    })
    .strict();

export const NestedIntFilterSchema: z.ZodType<Prisma.NestedIntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional(),
  })
  .strict();

export const NestedBoolWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional(),
    })
    .strict();

export const NestedStringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([
          z.string(),
          z.lazy(() => NestedStringNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional(),
    })
    .strict();

export const NestedIntNullableFilterSchema: z.ZodType<Prisma.NestedIntNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
    })
    .strict();

export const NestedBoolNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional().nullable(),
      not: z
        .union([
          z.boolean(),
          z.lazy(() => NestedBoolNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolNullableFilterSchema).optional(),
    })
    .strict();

export const NestedDateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
    })
    .strict();

export const NestedDateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([
          z.coerce.date(),
          z.lazy(() => NestedDateTimeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumGovernmentIdTypeNullableFilterSchema: z.ZodType<Prisma.NestedEnumGovernmentIdTypeNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(() => NestedEnumGovernmentIdTypeNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumKycStatusNullableFilterSchema: z.ZodType<Prisma.NestedEnumKycStatusNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NestedEnumKycStatusNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumGovernmentIdTypeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumGovernmentIdTypeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => GovernmentIdTypeSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NestedEnumGovernmentIdTypeNullableWithAggregatesFilterSchema,
          ),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumGovernmentIdTypeNullableFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumGovernmentIdTypeNullableFilterSchema)
        .optional(),
    })
    .strict();

export const NestedEnumKycStatusNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumKycStatusNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => KycStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NestedEnumKycStatusNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumKycStatusNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumKycStatusNullableFilterSchema).optional(),
    })
    .strict();

export const NestedIntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedIntNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional(),
    })
    .strict();

export const NestedFloatNullableFilterSchema: z.ZodType<Prisma.NestedFloatNullableFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedFloatNullableFilterSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumAccountStatusFilterSchema: z.ZodType<Prisma.NestedEnumAccountStatusFilter> =
  z
    .object({
      equals: z.lazy(() => AccountStatusSchema).optional(),
      in: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => NestedEnumAccountStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumAccountTypeFilterSchema: z.ZodType<Prisma.NestedEnumAccountTypeFilter> =
  z
    .object({
      equals: z.lazy(() => AccountTypeSchema).optional(),
      in: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => NestedEnumAccountTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumAccountOwnershipFilterSchema: z.ZodType<Prisma.NestedEnumAccountOwnershipFilter> =
  z
    .object({
      equals: z.lazy(() => AccountOwnershipSchema).optional(),
      in: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => NestedEnumAccountOwnershipFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedFloatFilterSchema: z.ZodType<Prisma.NestedFloatFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedFloatFilterSchema)])
      .optional(),
  })
  .strict();

export const NestedEnumAccountStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumAccountStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountStatusSchema).optional(),
      in: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => NestedEnumAccountStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumAccountTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumAccountTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountTypeSchema).optional(),
      in: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => NestedEnumAccountTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumAccountOwnershipWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumAccountOwnershipWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountOwnershipSchema).optional(),
      in: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountOwnershipSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => NestedEnumAccountOwnershipWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountOwnershipFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountOwnershipFilterSchema).optional(),
    })
    .strict();

export const NestedFloatWithAggregatesFilterSchema: z.ZodType<Prisma.NestedFloatWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([
          z.number(),
          z.lazy(() => NestedFloatWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatFilterSchema).optional(),
    })
    .strict();

export const NestedIntWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional(),
    })
    .strict();

export const NestedEnumAccountUserRoleFilterSchema: z.ZodType<Prisma.NestedEnumAccountUserRoleFilter> =
  z
    .object({
      equals: z.lazy(() => AccountUserRoleSchema).optional(),
      in: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => NestedEnumAccountUserRoleFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumAccountUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumAccountUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AccountUserRoleSchema).optional(),
      in: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AccountUserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => NestedEnumAccountUserRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAccountUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAccountUserRoleFilterSchema).optional(),
    })
    .strict();

export const NestedEnumJointAccountRequestStatusFilterSchema: z.ZodType<Prisma.NestedEnumJointAccountRequestStatusFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      in: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(() => NestedEnumJointAccountRequestStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumJointAccountRequestStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumJointAccountRequestStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      in: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountRequestStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => NestedEnumJointAccountRequestStatusWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumJointAccountRequestStatusFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumJointAccountRequestStatusFilterSchema)
        .optional(),
    })
    .strict();

export const NestedEnumJointAccountModRequestTypeFilterSchema: z.ZodType<Prisma.NestedEnumJointAccountModRequestTypeFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountModRequestTypeSchema).optional(),
      in: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(() => NestedEnumJointAccountModRequestTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumJointAccountModRequestTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumJointAccountModRequestTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => JointAccountModRequestTypeSchema).optional(),
      in: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => JointAccountModRequestTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              NestedEnumJointAccountModRequestTypeWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumJointAccountModRequestTypeFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumJointAccountModRequestTypeFilterSchema)
        .optional(),
    })
    .strict();

export const NestedEnumInvestmentPlanCategoryFilterSchema: z.ZodType<Prisma.NestedEnumInvestmentPlanCategoryFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentPlanCategorySchema).optional(),
      in: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(() => NestedEnumInvestmentPlanCategoryFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumProfitDistributionFilterSchema: z.ZodType<Prisma.NestedEnumProfitDistributionFilter> =
  z
    .object({
      equals: z.lazy(() => ProfitDistributionSchema).optional(),
      in: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => NestedEnumProfitDistributionFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumInvestmentPlanCategoryWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumInvestmentPlanCategoryWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentPlanCategorySchema).optional(),
      in: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentPlanCategorySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => NestedEnumInvestmentPlanCategoryWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z
        .lazy(() => NestedEnumInvestmentPlanCategoryFilterSchema)
        .optional(),
      _max: z
        .lazy(() => NestedEnumInvestmentPlanCategoryFilterSchema)
        .optional(),
    })
    .strict();

export const NestedEnumProfitDistributionWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumProfitDistributionWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ProfitDistributionSchema).optional(),
      in: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ProfitDistributionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => NestedEnumProfitDistributionWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumProfitDistributionFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumProfitDistributionFilterSchema).optional(),
    })
    .strict();

export const NestedEnumInvestmentStatusFilterSchema: z.ZodType<Prisma.NestedEnumInvestmentStatusFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentStatusSchema).optional(),
      in: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => NestedEnumInvestmentStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumInvestmentStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumInvestmentStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => InvestmentStatusSchema).optional(),
      in: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvestmentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => NestedEnumInvestmentStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumInvestmentStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumInvestmentStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumTransactionTypeFilterSchema: z.ZodType<Prisma.NestedEnumTransactionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionTypeSchema).optional(),
      in: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => NestedEnumTransactionTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumTransactionStatusFilterSchema: z.ZodType<Prisma.NestedEnumTransactionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionStatusSchema).optional(),
      in: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => NestedEnumTransactionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumTransactionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumTransactionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionTypeSchema).optional(),
      in: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => NestedEnumTransactionTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumTransactionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumTransactionTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumTransactionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumTransactionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => TransactionStatusSchema).optional(),
      in: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => TransactionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => NestedEnumTransactionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumTransactionStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumNotificationBodyTypeFilterSchema: z.ZodType<Prisma.NestedEnumNotificationBodyTypeFilter> =
  z
    .object({
      equals: z.lazy(() => NotificationBodyTypeSchema).optional(),
      in: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(() => NestedEnumNotificationBodyTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumNotificationBodyTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumNotificationBodyTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => NotificationBodyTypeSchema).optional(),
      in: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => NotificationBodyTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => NestedEnumNotificationBodyTypeWithAggregatesFilterSchema,
          ),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumNotificationBodyTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumNotificationBodyTypeFilterSchema).optional(),
    })
    .strict();

export const ProfileCreateWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      address: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      state: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      postalCode: z.string().optional().nullable(),
      governmentId: z.string().optional().nullable(),
      governmentIdType: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      governmentIdExt: z.string().optional().nullable(),
      kycStatus: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ProfileUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      address: z.string().optional().nullable(),
      country: z.string().optional().nullable(),
      state: z.string().optional().nullable(),
      city: z.string().optional().nullable(),
      postalCode: z.string().optional().nullable(),
      governmentId: z.string().optional().nullable(),
      governmentIdType: z
        .lazy(() => GovernmentIdTypeSchema)
        .optional()
        .nullable(),
      governmentIdExt: z.string().optional().nullable(),
      kycStatus: z
        .lazy(() => KycStatusSchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ProfileCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ProfileCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ProfileWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ProfileCreateWithoutUserInputSchema),
        z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const SessionCreateWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      impersonatedBy: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SessionUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      impersonatedBy: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SessionCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.SessionCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SessionCreateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const SessionCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.SessionCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SessionCreateManyUserInputSchema),
        z.lazy(() => SessionCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      accountId: z.string(),
      providerId: z.string(),
      accessToken: z.string().optional().nullable(),
      refreshToken: z.string().optional().nullable(),
      accessTokenExpiresAt: z.coerce.date().optional().nullable(),
      refreshTokenExpiresAt: z.coerce.date().optional().nullable(),
      scope: z.string().optional().nullable(),
      idToken: z.string().optional().nullable(),
      password: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      accountId: z.string(),
      providerId: z.string(),
      accessToken: z.string().optional().nullable(),
      refreshToken: z.string().optional().nullable(),
      accessTokenExpiresAt: z.coerce.date().optional().nullable(),
      refreshTokenExpiresAt: z.coerce.date().optional().nullable(),
      scope: z.string().optional().nullable(),
      idToken: z.string().optional().nullable(),
      password: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountCreateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.AccountCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AccountCreateManyUserInputSchema),
        z.lazy(() => AccountCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const FinancialAccountCreateWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema),
        z.lazy(() => FinancialAccountUncheckedCreateWithoutCreatorInputSchema),
      ]),
    })
    .strict();

export const FinancialAccountCreateManyCreatorInputEnvelopeSchema: z.ZodType<Prisma.FinancialAccountCreateManyCreatorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => FinancialAccountCreateManyCreatorInputSchema),
        z.lazy(() => FinancialAccountCreateManyCreatorInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountUserCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountUserCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutAccountUsersInputSchema,
      ),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInitiatorInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentCreateNestedManyWithoutInvestorInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedCreateNestedManyWithoutInitiatorInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedCreateNestedManyWithoutInvestorInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.AccountUserCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutUserInputSchema),
        z.lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUserCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.AccountUserCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AccountUserCreateManyUserInputSchema),
        z.lazy(() => AccountUserCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountRequestCreateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestCreateWithoutCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      recipient: z
        .lazy(
          () =>
            UserCreateNestedOneWithoutReceivedJointAccountRequestsInputSchema,
        )
        .optional(),
      financialAccount: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountRequestsInputSchema,
      ),
    })
    .strict();

export const JointAccountRequestUncheckedCreateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateWithoutCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      recipientId: z.string().optional().nullable(),
      financialAccountId: z.string(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestCreateOrConnectWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestCreateOrConnectWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestCreateManyCreatorInputEnvelopeSchema: z.ZodType<Prisma.JointAccountRequestCreateManyCreatorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => JointAccountRequestCreateManyCreatorInputSchema),
        z.lazy(() => JointAccountRequestCreateManyCreatorInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountRequestCreateWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestCreateWithoutRecipientInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedJointAccountRequestsInputSchema,
      ),
      financialAccount: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountRequestsInputSchema,
      ),
    })
    .strict();

export const JointAccountRequestUncheckedCreateWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateWithoutRecipientInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      financialAccountId: z.string(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestCreateOrConnectWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestCreateOrConnectWithoutRecipientInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestCreateManyRecipientInputEnvelopeSchema: z.ZodType<Prisma.JointAccountRequestCreateManyRecipientInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => JointAccountRequestCreateManyRecipientInputSchema),
        z.lazy(() => JointAccountRequestCreateManyRecipientInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestCreateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateWithoutCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      account: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountModRequestsInputSchema,
      ),
      transaction: z
        .lazy(
          () =>
            TransactionCreateNestedOneWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateWithoutCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateOrConnectWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateOrConnectWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestCreateManyCreatorInputEnvelopeSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyCreatorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => JointAccountModRequestCreateManyCreatorInputSchema),
        z
          .lazy(() => JointAccountModRequestCreateManyCreatorInputSchema)
          .array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const NotificationCreateWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      financialAccount: z
        .lazy(
          () => FinancialAccountCreateNestedOneWithoutNotificationsInputSchema,
        )
        .optional(),
    })
    .strict();

export const NotificationUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      financialAccountId: z.string().optional().nullable(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const NotificationCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.NotificationCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NotificationCreateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const NotificationCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.NotificationCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NotificationCreateManyUserInputSchema),
        z.lazy(() => NotificationCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateWithoutApproverInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      request: z.lazy(
        () => JointAccountModRequestCreateNestedOneWithoutApprovalsInputSchema,
      ),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedCreateWithoutApproverInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      jointAccountModRequestId: z.string(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateOrConnectWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateOrConnectWithoutApproverInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyApproverInputEnvelopeSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyApproverInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalCreateManyApproverInputSchema,
        ),
        z
          .lazy(
            () => JointAccountModRequestApprovalCreateManyApproverInputSchema,
          )
          .array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ProfileUpsertWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpsertWithoutUserInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ProfileUpdateWithoutUserInputSchema),
        z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ProfileCreateWithoutUserInputSchema),
        z.lazy(() => ProfileUncheckedCreateWithoutUserInputSchema),
      ]),
      where: z.lazy(() => ProfileWhereInputSchema).optional(),
    })
    .strict();

export const ProfileUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateToOneWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ProfileWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ProfileUpdateWithoutUserInputSchema),
        z.lazy(() => ProfileUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const ProfileUpdateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      state: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      postalCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentIdType: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional()
        .nullable(),
      governmentIdExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      kycStatus: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NullableEnumKycStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ProfileUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ProfileUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      country: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      state: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      city: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      postalCode: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      governmentIdType: z
        .union([
          z.lazy(() => GovernmentIdTypeSchema),
          z.lazy(
            () => NullableEnumGovernmentIdTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional()
        .nullable(),
      governmentIdExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      kycStatus: z
        .union([
          z.lazy(() => KycStatusSchema),
          z.lazy(() => NullableEnumKycStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SessionUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SessionUpdateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SessionCreateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const SessionUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SessionUpdateWithoutUserInputSchema),
        z.lazy(() => SessionUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const SessionUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => SessionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SessionUpdateManyMutationInputSchema),
        z.lazy(() => SessionUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const SessionScalarWhereInputSchema: z.ZodType<Prisma.SessionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => SessionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SessionScalarWhereInputSchema),
          z.lazy(() => SessionScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      token: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      ipAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const AccountUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AccountUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AccountCreateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AccountUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AccountUpdateManyMutationInputSchema),
        z.lazy(() => AccountUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountScalarWhereInputSchema: z.ZodType<Prisma.AccountScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AccountScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      accountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      providerId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      accessToken: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      refreshToken: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      scope: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      idToken: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      password: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithWhereUniqueWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithWhereUniqueWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutCreatorInputSchema),
        z.lazy(() => FinancialAccountUncheckedUpdateWithoutCreatorInputSchema),
      ]),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutCreatorInputSchema),
        z.lazy(() => FinancialAccountUncheckedCreateWithoutCreatorInputSchema),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithWhereUniqueWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithWhereUniqueWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutCreatorInputSchema),
        z.lazy(() => FinancialAccountUncheckedUpdateWithoutCreatorInputSchema),
      ]),
    })
    .strict();

export const FinancialAccountUpdateManyWithWhereWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUpdateManyWithWhereWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateManyMutationInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateManyWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountScalarWhereInputSchema: z.ZodType<Prisma.FinancialAccountScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => FinancialAccountScalarWhereInputSchema),
          z.lazy(() => FinancialAccountScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => FinancialAccountScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => FinancialAccountScalarWhereInputSchema),
          z.lazy(() => FinancialAccountScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      creatorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      number: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumAccountStatusFilterSchema),
          z.lazy(() => AccountStatusSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumAccountTypeFilterSchema),
          z.lazy(() => AccountTypeSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => EnumAccountOwnershipFilterSchema),
          z.lazy(() => AccountOwnershipSchema),
        ])
        .optional(),
      balance: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      totalTransactions: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      totalInvestments: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      firstTransactionAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      closedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      dormantAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const AccountUserUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AccountUserUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutUserInputSchema),
        z.lazy(() => AccountUserUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUserUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AccountUserUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUserUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountUserScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AccountUserUpdateManyMutationInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUserScalarWhereInputSchema: z.ZodType<Prisma.AccountUserScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountUserScalarWhereInputSchema),
          z.lazy(() => AccountUserScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AccountUserScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountUserScalarWhereInputSchema),
          z.lazy(() => AccountUserScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumAccountUserRoleFilterSchema),
          z.lazy(() => AccountUserRoleSchema),
        ])
        .optional(),
      ownership: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      autosign: z
        .union([z.lazy(() => BoolFilterSchema), z.boolean()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpsertWithWhereUniqueWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUpsertWithWhereUniqueWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => JointAccountRequestUpdateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedUpdateWithoutCreatorInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => JointAccountRequestCreateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedCreateWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpdateWithWhereUniqueWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateWithWhereUniqueWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => JointAccountRequestUpdateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedUpdateWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpdateManyWithWhereWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyWithWhereWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => JointAccountRequestUpdateManyMutationInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedUpdateManyWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestScalarWhereInputSchema: z.ZodType<Prisma.JointAccountRequestScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountRequestScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      creatorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      recipientName: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      recipientEmail: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      role: z
        .union([
          z.lazy(() => EnumAccountUserRoleFilterSchema),
          z.lazy(() => AccountUserRoleSchema),
        ])
        .optional(),
      ownership: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      recipientId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      reminderCount: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumJointAccountRequestStatusFilterSchema),
          z.lazy(() => JointAccountRequestStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpsertWithWhereUniqueWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUpsertWithWhereUniqueWithoutRecipientInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => JointAccountRequestUpdateWithoutRecipientInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedUpdateWithoutRecipientInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => JointAccountRequestCreateWithoutRecipientInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedCreateWithoutRecipientInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpdateWithWhereUniqueWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateWithWhereUniqueWithoutRecipientInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => JointAccountRequestUpdateWithoutRecipientInputSchema),
        z.lazy(
          () => JointAccountRequestUncheckedUpdateWithoutRecipientInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpdateManyWithWhereWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyWithWhereWithoutRecipientInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => JointAccountRequestUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpsertWithWhereUniqueWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUpsertWithWhereUniqueWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedUpdateWithoutCreatorInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedCreateWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateWithWhereUniqueWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithWhereUniqueWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutCreatorInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedUpdateWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateManyWithWhereWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyWithWhereWithoutCreatorInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestScalarWhereInputSchema: z.ZodType<Prisma.JointAccountModRequestScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountModRequestScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
          z.lazy(() => JointAccountModRequestScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      creatorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumJointAccountModRequestTypeFilterSchema),
          z.lazy(() => JointAccountModRequestTypeSchema),
        ])
        .optional(),
      transactionId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const NotificationUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NotificationUpdateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => NotificationCreateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const NotificationUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NotificationUpdateWithoutUserInputSchema),
        z.lazy(() => NotificationUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const NotificationUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => NotificationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NotificationUpdateManyMutationInputSchema),
        z.lazy(() => NotificationUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const NotificationScalarWhereInputSchema: z.ZodType<Prisma.NotificationScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => NotificationScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => NotificationScalarWhereInputSchema),
          z.lazy(() => NotificationScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      body: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      bodyType: z
        .union([
          z.lazy(() => EnumNotificationBodyTypeFilterSchema),
          z.lazy(() => NotificationBodyTypeSchema),
        ])
        .optional(),
      userId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      link: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      isRead: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutApproverInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
      update: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalUpdateWithoutApproverInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateWithoutApproverInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalCreateWithoutApproverInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateWithoutApproverInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutApproverInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
      data: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalUpdateWithoutApproverInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateWithoutApproverInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyWithWhereWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyWithWhereWithoutApproverInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
      data: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalUpdateManyMutationInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalScalarWhereInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
            .array(),
        ])
        .optional(),
      OR: z
        .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
          z
            .lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema)
            .array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      jointAccountModRequestId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      approverId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumJointAccountRequestStatusFilterSchema),
          z.lazy(() => JointAccountRequestStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const UserCreateWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateWithoutSessionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSessionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutSessionsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSessionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema),
      ]),
    })
    .strict();

export const UserUpsertWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpsertWithoutSessionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSessionsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSessionsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutSessionsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSessionsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUpdateWithoutSessionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutSessionsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSessionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateWithoutAccountsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAccountsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
      ]),
    })
    .strict();

export const UserUpsertWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpsertWithoutAccountsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateWithoutAccountsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAccountsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateWithoutProfileInputSchema: z.ZodType<Prisma.UserCreateWithoutProfileInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutProfileInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutProfileInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutProfileInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutProfileInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutProfileInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema),
      ]),
    })
    .strict();

export const UserUpsertWithoutProfileInputSchema: z.ZodType<Prisma.UserUpsertWithoutProfileInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutProfileInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutProfileInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutProfileInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutProfileInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutProfileInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutProfileInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutProfileInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutProfileInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutProfileInputSchema: z.ZodType<Prisma.UserUpdateWithoutProfileInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutProfileInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutProfileInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutBusinessProfileInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutBusinessProfileInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutBusinessProfileInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutBusinessProfileInputSchema),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutBusinessProfileInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpsertWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutBusinessProfileInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutBusinessProfileInputSchema),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutBusinessProfileInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutBusinessProfileInputSchema),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutBusinessProfileInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutBusinessProfileInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutBusinessProfileInputSchema),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutBusinessProfileInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutBusinessProfileInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutBusinessProfileInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutBusinessProfileInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserCreateWithoutCreatedAccountsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCreatedAccountsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCreatedAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutCreatedAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCreatedAccountsInputSchema),
      ]),
    })
    .strict();

export const BusinessProfileCreateWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileCreateWithoutAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      address: z.string().optional().nullable(),
      creationMonth: z.string().optional().nullable(),
      creationYear: z.number().int().optional().nullable(),
      proofOfAddress: z.string().optional().nullable(),
      proofOfAddressExt: z.string().optional().nullable(),
      certificate: z.string().optional().nullable(),
      certificateExt: z.string().optional().nullable(),
      approved: z.boolean(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const BusinessProfileUncheckedCreateWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedCreateWithoutAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      address: z.string().optional().nullable(),
      creationMonth: z.string().optional().nullable(),
      creationYear: z.number().int().optional().nullable(),
      proofOfAddress: z.string().optional().nullable(),
      proofOfAddressExt: z.string().optional().nullable(),
      certificate: z.string().optional().nullable(),
      certificateExt: z.string().optional().nullable(),
      approved: z.boolean(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const BusinessProfileCreateOrConnectWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileCreateOrConnectWithoutAccountInput> =
  z
    .object({
      where: z.lazy(() => BusinessProfileWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BusinessProfileCreateWithoutAccountInputSchema),
        z.lazy(() => BusinessProfileUncheckedCreateWithoutAccountInputSchema),
      ]),
    })
    .strict();

export const AccountUserCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(
        () => UserCreateNestedOneWithoutAccountMembershipsInputSchema,
      ),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInitiatorInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentCreateNestedManyWithoutInvestorInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedCreateNestedManyWithoutInitiatorInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedCreateNestedManyWithoutInvestorInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserCreateOrConnectWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserCreateOrConnectWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const AccountUserCreateManyFinancialAccountInputEnvelopeSchema: z.ZodType<Prisma.AccountUserCreateManyFinancialAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AccountUserCreateManyFinancialAccountInputSchema),
        z.lazy(() => AccountUserCreateManyFinancialAccountInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountRequestCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedJointAccountRequestsInputSchema,
      ),
      recipient: z
        .lazy(
          () =>
            UserCreateNestedOneWithoutReceivedJointAccountRequestsInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      recipientId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestCreateOrConnectWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestCreateOrConnectWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestCreateManyFinancialAccountInputEnvelopeSchema: z.ZodType<Prisma.JointAccountRequestCreateManyFinancialAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => JointAccountRequestCreateManyFinancialAccountInputSchema),
        z
          .lazy(() => JointAccountRequestCreateManyFinancialAccountInputSchema)
          .array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestCreateWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateWithoutAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () =>
          UserCreateNestedOneWithoutCreatedJointAccountModRequestsInputSchema,
      ),
      transaction: z
        .lazy(
          () =>
            TransactionCreateNestedOneWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateWithoutAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateOrConnectWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateOrConnectWithoutAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestCreateManyAccountInputEnvelopeSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => JointAccountModRequestCreateManyAccountInputSchema),
        z
          .lazy(() => JointAccountModRequestCreateManyAccountInputSchema)
          .array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const NotificationCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z
        .lazy(() => UserCreateNestedOneWithoutNotificationsInputSchema)
        .optional(),
    })
    .strict();

export const NotificationUncheckedCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUncheckedCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      userId: z.string().optional().nullable(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const NotificationCreateOrConnectWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationCreateOrConnectWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => NotificationCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const NotificationCreateManyFinancialAccountInputEnvelopeSchema: z.ZodType<Prisma.NotificationCreateManyFinancialAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => NotificationCreateManyFinancialAccountInputSchema),
        z.lazy(() => NotificationCreateManyFinancialAccountInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const TransactionCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionCreateManyFinancialAccountInputEnvelopeSchema: z.ZodType<Prisma.TransactionCreateManyFinancialAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => TransactionCreateManyFinancialAccountInputSchema),
        z.lazy(() => TransactionCreateManyFinancialAccountInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const TransactionCreateWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionCreateWithoutRecipientAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutRecipientAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutRecipientAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutRecipientAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionCreateManyRecipientAccountInputEnvelopeSchema: z.ZodType<Prisma.TransactionCreateManyRecipientAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => TransactionCreateManyRecipientAccountInputSchema),
        z.lazy(() => TransactionCreateManyRecipientAccountInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const InvestmentCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      investor: z.lazy(
        () => AccountUserCreateNestedOneWithoutInvestmentsInputSchema,
      ),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInvestmentInputSchema)
        .optional(),
    })
    .strict();

export const InvestmentUncheckedCreateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUncheckedCreateWithoutFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      investorId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutInvestmentInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentCreateOrConnectWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentCreateOrConnectWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const InvestmentCreateManyFinancialAccountInputEnvelopeSchema: z.ZodType<Prisma.InvestmentCreateManyFinancialAccountInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => InvestmentCreateManyFinancialAccountInputSchema),
        z.lazy(() => InvestmentCreateManyFinancialAccountInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UserUpsertWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserUpsertWithoutCreatedAccountsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutCreatedAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCreatedAccountsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutCreatedAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCreatedAccountsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCreatedAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutCreatedAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCreatedAccountsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserUpdateWithoutCreatedAccountsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutCreatedAccountsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCreatedAccountsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const BusinessProfileUpsertWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileUpsertWithoutAccountInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BusinessProfileUpdateWithoutAccountInputSchema),
        z.lazy(() => BusinessProfileUncheckedUpdateWithoutAccountInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BusinessProfileCreateWithoutAccountInputSchema),
        z.lazy(() => BusinessProfileUncheckedCreateWithoutAccountInputSchema),
      ]),
      where: z.lazy(() => BusinessProfileWhereInputSchema).optional(),
    })
    .strict();

export const BusinessProfileUpdateToOneWithWhereWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileUpdateToOneWithWhereWithoutAccountInput> =
  z
    .object({
      where: z.lazy(() => BusinessProfileWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BusinessProfileUpdateWithoutAccountInputSchema),
        z.lazy(() => BusinessProfileUncheckedUpdateWithoutAccountInputSchema),
      ]),
    })
    .strict();

export const BusinessProfileUpdateWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileUpdateWithoutAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileUncheckedUpdateWithoutAccountInputSchema: z.ZodType<Prisma.BusinessProfileUncheckedUpdateWithoutAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      address: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationMonth: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      creationYear: z
        .union([
          z.number().int(),
          z.lazy(() => NullableIntFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      proofOfAddressExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificate: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      certificateExt: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approved: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUpsertWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUpsertWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AccountUserUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => AccountUserUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => AccountUserUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const AccountUserUpdateWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUpdateWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AccountUserUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => AccountUserUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const AccountUserUpdateManyWithWhereWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUpdateManyWithWhereWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => AccountUserScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AccountUserUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpsertWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUpsertWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      update: z.union([
        z.lazy(
          () => JointAccountRequestUpdateWithoutFinancialAccountInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountRequestUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => JointAccountRequestCreateWithoutFinancialAccountInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountRequestUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpdateWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestWhereUniqueInputSchema),
      data: z.union([
        z.lazy(
          () => JointAccountRequestUpdateWithoutFinancialAccountInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountRequestUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountRequestUpdateManyWithWhereWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyWithWhereWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountRequestScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => JointAccountRequestUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpsertWithWhereUniqueWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUpsertWithWhereUniqueWithoutAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutAccountInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedUpdateWithoutAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutAccountInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedCreateWithoutAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateWithWhereUniqueWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithWhereUniqueWithoutAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutAccountInputSchema),
        z.lazy(
          () => JointAccountModRequestUncheckedUpdateWithoutAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateManyWithWhereWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyWithWhereWithoutAccountInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const NotificationUpsertWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUpsertWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => NotificationUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => NotificationUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => NotificationCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => NotificationUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const NotificationUpdateWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUpdateWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => NotificationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => NotificationUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => NotificationUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const NotificationUpdateManyWithWhereWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUpdateManyWithWhereWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => NotificationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => NotificationUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpsertWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUpsertWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => TransactionUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUpdateWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateManyWithWhereWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithWhereWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionScalarWhereInputSchema: z.ZodType<Prisma.TransactionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => TransactionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => TransactionScalarWhereInputSchema),
          z.lazy(() => TransactionScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      amount: z.union([z.lazy(() => FloatFilterSchema), z.number()]).optional(),
      currency: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      USDAmount: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      rate: z.union([z.lazy(() => FloatFilterSchema), z.number()]).optional(),
      charges: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumTransactionTypeFilterSchema),
          z.lazy(() => TransactionTypeSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      recipientAccountId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      investmentId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumTransactionStatusFilterSchema),
          z.lazy(() => TransactionStatusSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      failedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      failReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      bank: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      bankAccount: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const TransactionUpsertWithWhereUniqueWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUpsertWithWhereUniqueWithoutRecipientAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => TransactionUpdateWithoutRecipientAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutRecipientAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutRecipientAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutRecipientAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateWithWhereUniqueWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUpdateWithWhereUniqueWithoutRecipientAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateWithoutRecipientAccountInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutRecipientAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateManyWithWhereWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithWhereWithoutRecipientAccountInput> =
  z
    .object({
      where: z.lazy(() => TransactionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const InvestmentUpsertWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUpsertWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => InvestmentUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => InvestmentUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => InvestmentCreateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => InvestmentUncheckedCreateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const InvestmentUpdateWithWhereUniqueWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUpdateWithWhereUniqueWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => InvestmentUpdateWithoutFinancialAccountInputSchema),
        z.lazy(
          () => InvestmentUncheckedUpdateWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const InvestmentUpdateManyWithWhereWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUpdateManyWithWhereWithoutFinancialAccountInput> =
  z
    .object({
      where: z.lazy(() => InvestmentScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => InvestmentUpdateManyMutationInputSchema),
        z.lazy(
          () => InvestmentUncheckedUpdateManyWithoutFinancialAccountInputSchema,
        ),
      ]),
    })
    .strict();

export const InvestmentScalarWhereInputSchema: z.ZodType<Prisma.InvestmentScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => InvestmentScalarWhereInputSchema),
          z.lazy(() => InvestmentScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => InvestmentScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => InvestmentScalarWhereInputSchema),
          z.lazy(() => InvestmentScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      financialAccountId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      investorId: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      deposit: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      investmentName: z
        .union([z.lazy(() => StringFilterSchema), z.string()])
        .optional(),
      totalProfit: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      profitCount: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumInvestmentStatusFilterSchema),
          z.lazy(() => InvestmentStatusSchema),
        ])
        .optional(),
      pausedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      pausedReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      closedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      closedReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => EnumInvestmentPlanCategoryFilterSchema),
          z.lazy(() => InvestmentPlanCategorySchema),
        ])
        .optional(),
      daysCompleted: z
        .union([z.lazy(() => IntFilterSchema), z.number()])
        .optional(),
      duration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      totalReturn: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      periodicReturn: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => EnumProfitDistributionFilterSchema),
          z.lazy(() => ProfitDistributionSchema),
        ])
        .optional(),
      terminationFee: z
        .union([z.lazy(() => FloatFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const UserCreateWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserCreateWithoutAccountMembershipsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAccountMembershipsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAccountMembershipsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountMembershipsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountMembershipsInputSchema),
      ]),
    })
    .strict();

export const FinancialAccountCreateWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutAccountUsersInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutAccountUsersInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutAccountUsersInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutAccountUsersInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutAccountUsersInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionCreateWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionCreateWithoutInitiatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutInitiatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutInitiatorInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutInitiatorInputSchema),
        z.lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema),
      ]),
    })
    .strict();

export const TransactionCreateManyInitiatorInputEnvelopeSchema: z.ZodType<Prisma.TransactionCreateManyInitiatorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => TransactionCreateManyInitiatorInputSchema),
        z.lazy(() => TransactionCreateManyInitiatorInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const InvestmentCreateWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentCreateWithoutInvestorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInvestmentInputSchema)
        .optional(),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutInvestmentsInputSchema,
      ),
    })
    .strict();

export const InvestmentUncheckedCreateWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUncheckedCreateWithoutInvestorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutInvestmentInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentCreateOrConnectWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentCreateOrConnectWithoutInvestorInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InvestmentCreateWithoutInvestorInputSchema),
        z.lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema),
      ]),
    })
    .strict();

export const InvestmentCreateManyInvestorInputEnvelopeSchema: z.ZodType<Prisma.InvestmentCreateManyInvestorInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => InvestmentCreateManyInvestorInputSchema),
        z.lazy(() => InvestmentCreateManyInvestorInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UserUpsertWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserUpsertWithoutAccountMembershipsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAccountMembershipsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountMembershipsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountMembershipsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountMembershipsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAccountMembershipsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAccountMembershipsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountMembershipsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserUpdateWithoutAccountMembershipsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutAccountMembershipsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAccountMembershipsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutAccountUsersInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutAccountUsersInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutAccountUsersInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutAccountUsersInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutAccountUsersInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutAccountUsersInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutAccountUsersInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutAccountUsersInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutAccountUsersInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutAccountUsersInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutAccountUsersInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUpsertWithWhereUniqueWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUpsertWithWhereUniqueWithoutInitiatorInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => TransactionUpdateWithoutInitiatorInputSchema),
        z.lazy(() => TransactionUncheckedUpdateWithoutInitiatorInputSchema),
      ]),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutInitiatorInputSchema),
        z.lazy(() => TransactionUncheckedCreateWithoutInitiatorInputSchema),
      ]),
    })
    .strict();

export const TransactionUpdateWithWhereUniqueWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUpdateWithWhereUniqueWithoutInitiatorInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateWithoutInitiatorInputSchema),
        z.lazy(() => TransactionUncheckedUpdateWithoutInitiatorInputSchema),
      ]),
    })
    .strict();

export const TransactionUpdateManyWithWhereWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithWhereWithoutInitiatorInput> =
  z
    .object({
      where: z.lazy(() => TransactionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateManyMutationInputSchema),
        z.lazy(() => TransactionUncheckedUpdateManyWithoutInitiatorInputSchema),
      ]),
    })
    .strict();

export const InvestmentUpsertWithWhereUniqueWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUpsertWithWhereUniqueWithoutInvestorInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => InvestmentUpdateWithoutInvestorInputSchema),
        z.lazy(() => InvestmentUncheckedUpdateWithoutInvestorInputSchema),
      ]),
      create: z.union([
        z.lazy(() => InvestmentCreateWithoutInvestorInputSchema),
        z.lazy(() => InvestmentUncheckedCreateWithoutInvestorInputSchema),
      ]),
    })
    .strict();

export const InvestmentUpdateWithWhereUniqueWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUpdateWithWhereUniqueWithoutInvestorInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => InvestmentUpdateWithoutInvestorInputSchema),
        z.lazy(() => InvestmentUncheckedUpdateWithoutInvestorInputSchema),
      ]),
    })
    .strict();

export const InvestmentUpdateManyWithWhereWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUpdateManyWithWhereWithoutInvestorInput> =
  z
    .object({
      where: z.lazy(() => InvestmentScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => InvestmentUpdateManyMutationInputSchema),
        z.lazy(() => InvestmentUncheckedUpdateManyWithoutInvestorInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserCreateWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutCreatedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutCreatedJointAccountRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserCreateWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserCreateWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutReceivedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutReceivedJointAccountRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountCreateWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutJointAccountRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutJointAccountRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutJointAccountRequestsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => FinancialAccountCreateWithoutJointAccountRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutJointAccountRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserUpsertWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUpsertWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutCreatedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutCreatedJointAccountRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutCreatedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutCreatedJointAccountRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutCreatedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutCreatedJointAccountRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserUpdateWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUpdateWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutCreatedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCreatedJointAccountRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUpsertWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUpsertWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutReceivedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutReceivedJointAccountRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutReceivedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutReceivedJointAccountRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutReceivedJointAccountRequestsInputSchema),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutReceivedJointAccountRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserUpdateWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUpdateWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutReceivedJointAccountRequestsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutReceivedJointAccountRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutJointAccountRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(
          () => FinancialAccountUpdateWithoutJointAccountRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutJointAccountRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => FinancialAccountCreateWithoutJointAccountRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutJointAccountRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutJointAccountRequestsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(
          () => FinancialAccountUpdateWithoutJointAccountRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutJointAccountRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutJointAccountRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutJointAccountRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutJointAccountRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserCreateWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => UserCreateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountCreateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => FinancialAccountCreateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionCreateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionCreateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => TransactionCreateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            TransactionUncheckedCreateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalCreateWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateWithoutRequestInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      approver: z.lazy(
        () =>
          UserCreateNestedOneWithoutApprovedJointAccountModRequestsInputSchema,
      ),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedCreateWithoutRequestInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      approverId: z.string(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateOrConnectWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateOrConnectWithoutRequestInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyRequestInputEnvelopeSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyRequestInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalCreateManyRequestInputSchema,
        ),
        z
          .lazy(
            () => JointAccountModRequestApprovalCreateManyRequestInputSchema,
          )
          .array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UserUpsertWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUpsertWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(
          () => UserUpdateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => UserCreateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(
          () => UserUpdateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutCreatedJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserUpdateWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUpdateWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutCreatedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCreatedJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutJointAccountModRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(
          () => FinancialAccountUpdateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => FinancialAccountCreateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(
          () => FinancialAccountUpdateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUpsertWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionUpsertWithoutJointAccountModRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(
          () => TransactionUpdateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            TransactionUncheckedUpdateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => TransactionCreateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            TransactionUncheckedCreateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => TransactionWhereInputSchema).optional(),
    })
    .strict();

export const TransactionUpdateToOneWithWhereWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionUpdateToOneWithWhereWithoutJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(
          () => TransactionUpdateWithoutJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            TransactionUncheckedUpdateWithoutJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutJointAccountModRequestsInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpsertWithWhereUniqueWithoutRequestInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
      update: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalUpdateWithoutRequestInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateWithoutRequestInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalCreateWithoutRequestInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateWithoutRequestInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateWithWhereUniqueWithoutRequestInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalWhereUniqueInputSchema),
      data: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalUpdateWithoutRequestInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateWithoutRequestInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyWithWhereWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyWithWhereWithoutRequestInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestApprovalScalarWhereInputSchema),
      data: z.union([
        z.lazy(
          () => JointAccountModRequestApprovalUpdateManyMutationInputSchema,
        ),
        z.lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestCreateWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateWithoutApprovalsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () =>
          UserCreateNestedOneWithoutCreatedJointAccountModRequestsInputSchema,
      ),
      account: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountModRequestsInputSchema,
      ),
      transaction: z
        .lazy(
          () =>
            TransactionCreateNestedOneWithoutJointAccountModRequestsInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateWithoutApprovalsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestCreateOrConnectWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateOrConnectWithoutApprovalsInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutApprovalsInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedCreateWithoutApprovalsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserCreateWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserCreateWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => UserCreateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpsertWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestUpsertWithoutApprovalsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutApprovalsInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateWithoutApprovalsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutApprovalsInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedCreateWithoutApprovalsInputSchema,
        ),
      ]),
      where: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
    })
    .strict();

export const JointAccountModRequestUpdateToOneWithWhereWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateToOneWithWhereWithoutApprovalsInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutApprovalsInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateWithoutApprovalsInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithoutApprovalsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      account: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      transaction: z
        .lazy(
          () =>
            TransactionUpdateOneWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateWithoutApprovalsInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateWithoutApprovalsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpsertWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUpsertWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      update: z.union([
        z.lazy(
          () => UserUpdateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => UserCreateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedCreateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(
          () => UserUpdateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
        z.lazy(
          () =>
            UserUncheckedUpdateWithoutApprovedJointAccountModRequestsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserUpdateWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUpdateWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutApprovedJointAccountModRequestsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutApprovedJointAccountModRequestsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(() => NotificationUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserCreateWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserCreateWithoutInvestmentsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(
        () => UserCreateNestedOneWithoutAccountMembershipsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutAccountUsersInputSchema,
      ),
      transactions: z
        .lazy(() => TransactionCreateNestedManyWithoutInitiatorInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedCreateWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateWithoutInvestmentsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      financialAccountId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedCreateNestedManyWithoutInitiatorInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserCreateOrConnectWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserCreateOrConnectWithoutInvestmentsInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutInvestmentsInputSchema),
        z.lazy(() => AccountUserUncheckedCreateWithoutInvestmentsInputSchema),
      ]),
    })
    .strict();

export const TransactionCreateWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionCreateWithoutInvestmentInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutInvestmentInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutInvestmentInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutInvestmentInputSchema),
        z.lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema),
      ]),
    })
    .strict();

export const TransactionCreateManyInvestmentInputEnvelopeSchema: z.ZodType<Prisma.TransactionCreateManyInvestmentInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => TransactionCreateManyInvestmentInputSchema),
        z.lazy(() => TransactionCreateManyInvestmentInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const FinancialAccountCreateWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutInvestmentsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutInvestmentsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutInvestmentsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutInvestmentsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutInvestmentsInputSchema,
        ),
      ]),
    })
    .strict();

export const AccountUserUpsertWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserUpsertWithoutInvestmentsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => AccountUserUpdateWithoutInvestmentsInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateWithoutInvestmentsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutInvestmentsInputSchema),
        z.lazy(() => AccountUserUncheckedCreateWithoutInvestmentsInputSchema),
      ]),
      where: z.lazy(() => AccountUserWhereInputSchema).optional(),
    })
    .strict();

export const AccountUserUpdateToOneWithWhereWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserUpdateToOneWithWhereWithoutInvestmentsInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => AccountUserUpdateWithoutInvestmentsInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateWithoutInvestmentsInputSchema),
      ]),
    })
    .strict();

export const AccountUserUpdateWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserUpdateWithoutInvestmentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutAccountMembershipsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutAccountUsersNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInitiatorNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateWithoutInvestmentsInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateWithoutInvestmentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedUpdateManyWithoutInitiatorNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUpsertWithWhereUniqueWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUpsertWithWhereUniqueWithoutInvestmentInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => TransactionUpdateWithoutInvestmentInputSchema),
        z.lazy(() => TransactionUncheckedUpdateWithoutInvestmentInputSchema),
      ]),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutInvestmentInputSchema),
        z.lazy(() => TransactionUncheckedCreateWithoutInvestmentInputSchema),
      ]),
    })
    .strict();

export const TransactionUpdateWithWhereUniqueWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUpdateWithWhereUniqueWithoutInvestmentInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateWithoutInvestmentInputSchema),
        z.lazy(() => TransactionUncheckedUpdateWithoutInvestmentInputSchema),
      ]),
    })
    .strict();

export const TransactionUpdateManyWithWhereWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithWhereWithoutInvestmentInput> =
  z
    .object({
      where: z.lazy(() => TransactionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateManyMutationInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateManyWithoutInvestmentInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpsertWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutInvestmentsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutInvestmentsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutInvestmentsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutInvestmentsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutInvestmentsInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutInvestmentsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutInvestmentsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutInvestmentsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutInvestmentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutInvestmentsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutInvestmentsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserCreateWithoutTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(
        () => UserCreateNestedOneWithoutAccountMembershipsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutAccountUsersInputSchema,
      ),
      investments: z
        .lazy(() => InvestmentCreateNestedManyWithoutInvestorInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserUncheckedCreateWithoutTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      financialAccountId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedCreateNestedManyWithoutInvestorInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserCreateOrConnectWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserCreateOrConnectWithoutTransactionsInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutTransactionsInputSchema),
        z.lazy(() => AccountUserUncheckedCreateWithoutTransactionsInputSchema),
      ]),
    })
    .strict();

export const FinancialAccountCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutTransactionsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutTransactionsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutTransactionsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountCreateWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutReceivedTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutReceivedTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutReceivedTransactionsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(
          () => FinancialAccountCreateWithoutReceivedTransactionsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutReceivedTransactionsInputSchema,
        ),
      ]),
    })
    .strict();

export const InvestmentCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentCreateWithoutTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      investor: z.lazy(
        () => AccountUserCreateNestedOneWithoutInvestmentsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutInvestmentsInputSchema,
      ),
    })
    .strict();

export const InvestmentUncheckedCreateWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentUncheckedCreateWithoutTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      investorId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentCreateOrConnectWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentCreateOrConnectWithoutTransactionsInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => InvestmentCreateWithoutTransactionsInputSchema),
        z.lazy(() => InvestmentUncheckedCreateWithoutTransactionsInputSchema),
      ]),
    })
    .strict();

export const JointAccountModRequestCreateWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateWithoutTransactionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () =>
          UserCreateNestedOneWithoutCreatedJointAccountModRequestsInputSchema,
      ),
      account: z.lazy(
        () =>
          FinancialAccountCreateNestedOneWithoutJointAccountModRequestsInputSchema,
      ),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedCreateWithoutTransactionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutRequestInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateOrConnectWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateOrConnectWithoutTransactionInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutTransactionInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestCreateManyTransactionInputEnvelopeSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyTransactionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => JointAccountModRequestCreateManyTransactionInputSchema),
        z
          .lazy(() => JointAccountModRequestCreateManyTransactionInputSchema)
          .array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const TransactionCreateWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionCreateWithoutChildTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionCreateNestedOneWithoutChildTransactionsInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutChildTransactionsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutChildTransactionsInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutChildTransactionsInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutChildTransactionsInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionCreateWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionCreateWithoutParentTransactionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      initiator: z.lazy(
        () => AccountUserCreateNestedOneWithoutTransactionsInputSchema,
      ),
      financialAccount: z.lazy(
        () => FinancialAccountCreateNestedOneWithoutTransactionsInputSchema,
      ),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountCreateNestedOneWithoutReceivedTransactionsInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentCreateNestedOneWithoutTransactionsInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedCreateWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUncheckedCreateWithoutParentTransactionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutTransactionInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutParentTransactionInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionCreateOrConnectWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionCreateOrConnectWithoutParentTransactionInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutParentTransactionInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutParentTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionCreateManyParentTransactionInputEnvelopeSchema: z.ZodType<Prisma.TransactionCreateManyParentTransactionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => TransactionCreateManyParentTransactionInputSchema),
        z.lazy(() => TransactionCreateManyParentTransactionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountUserUpsertWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserUpsertWithoutTransactionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => AccountUserUpdateWithoutTransactionsInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateWithoutTransactionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AccountUserCreateWithoutTransactionsInputSchema),
        z.lazy(() => AccountUserUncheckedCreateWithoutTransactionsInputSchema),
      ]),
      where: z.lazy(() => AccountUserWhereInputSchema).optional(),
    })
    .strict();

export const AccountUserUpdateToOneWithWhereWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserUpdateToOneWithWhereWithoutTransactionsInput> =
  z
    .object({
      where: z.lazy(() => AccountUserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => AccountUserUpdateWithoutTransactionsInputSchema),
        z.lazy(() => AccountUserUncheckedUpdateWithoutTransactionsInputSchema),
      ]),
    })
    .strict();

export const AccountUserUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserUpdateWithoutTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutAccountMembershipsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutAccountUsersNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(() => InvestmentUpdateManyWithoutInvestorNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateWithoutTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedUpdateManyWithoutInvestorNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutTransactionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutTransactionsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutTransactionsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutTransactionsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutTransactionsInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutTransactionsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutTransactionsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutTransactionsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutReceivedTransactionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(
          () => FinancialAccountUpdateWithoutReceivedTransactionsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutReceivedTransactionsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(
          () => FinancialAccountCreateWithoutReceivedTransactionsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedCreateWithoutReceivedTransactionsInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutReceivedTransactionsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(
          () => FinancialAccountUpdateWithoutReceivedTransactionsInputSchema,
        ),
        z.lazy(
          () =>
            FinancialAccountUncheckedUpdateWithoutReceivedTransactionsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutReceivedTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutReceivedTransactionsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutReceivedTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUpsertWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentUpsertWithoutTransactionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => InvestmentUpdateWithoutTransactionsInputSchema),
        z.lazy(() => InvestmentUncheckedUpdateWithoutTransactionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => InvestmentCreateWithoutTransactionsInputSchema),
        z.lazy(() => InvestmentUncheckedCreateWithoutTransactionsInputSchema),
      ]),
      where: z.lazy(() => InvestmentWhereInputSchema).optional(),
    })
    .strict();

export const InvestmentUpdateToOneWithWhereWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentUpdateToOneWithWhereWithoutTransactionsInput> =
  z
    .object({
      where: z.lazy(() => InvestmentWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => InvestmentUpdateWithoutTransactionsInputSchema),
        z.lazy(() => InvestmentUncheckedUpdateWithoutTransactionsInputSchema),
      ]),
    })
    .strict();

export const InvestmentUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentUpdateWithoutTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investor: z
        .lazy(
          () => AccountUserUpdateOneRequiredWithoutInvestmentsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutInvestmentsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateWithoutTransactionsInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateWithoutTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpsertWithWhereUniqueWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUpsertWithWhereUniqueWithoutTransactionInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutTransactionInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateWithoutTransactionInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => JointAccountModRequestCreateWithoutTransactionInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedCreateWithoutTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateWithWhereUniqueWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithWhereUniqueWithoutTransactionInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateWithoutTransactionInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateWithoutTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const JointAccountModRequestUpdateManyWithWhereWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyWithWhereWithoutTransactionInput> =
  z
    .object({
      where: z.lazy(() => JointAccountModRequestScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => JointAccountModRequestUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpsertWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionUpsertWithoutChildTransactionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => TransactionUpdateWithoutChildTransactionsInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutChildTransactionsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutChildTransactionsInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutChildTransactionsInputSchema,
        ),
      ]),
      where: z.lazy(() => TransactionWhereInputSchema).optional(),
    })
    .strict();

export const TransactionUpdateToOneWithWhereWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionUpdateToOneWithWhereWithoutChildTransactionsInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => TransactionUpdateWithoutChildTransactionsInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutChildTransactionsInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutChildTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutChildTransactionsInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutChildTransactionsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUpsertWithWhereUniqueWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUpsertWithWhereUniqueWithoutParentTransactionInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => TransactionUpdateWithoutParentTransactionInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutParentTransactionInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => TransactionCreateWithoutParentTransactionInputSchema),
        z.lazy(
          () => TransactionUncheckedCreateWithoutParentTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateWithWhereUniqueWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUpdateWithWhereUniqueWithoutParentTransactionInput> =
  z
    .object({
      where: z.lazy(() => TransactionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateWithoutParentTransactionInputSchema),
        z.lazy(
          () => TransactionUncheckedUpdateWithoutParentTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const TransactionUpdateManyWithWhereWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUpdateManyWithWhereWithoutParentTransactionInput> =
  z
    .object({
      where: z.lazy(() => TransactionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => TransactionUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionInputSchema,
        ),
      ]),
    })
    .strict();

export const UserCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateWithoutNotificationsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountCreateNestedManyWithoutCreatorInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutNotificationsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      email: z.string(),
      emailVerified: z.boolean(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      banned: z.boolean().optional().nullable(),
      banReason: z.string().optional().nullable(),
      banExpires: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      profile: z
        .lazy(() => ProfileUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutRecipientInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutCreatorInputSchema,
        )
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedCreateNestedManyWithoutApproverInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutNotificationsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutNotificationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
      ]),
    })
    .strict();

export const FinancialAccountCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountCreateWithoutNotificationsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      creator: z.lazy(
        () => UserCreateNestedOneWithoutCreatedAccountsInputSchema,
      ),
      businessProfile: z
        .lazy(() => BusinessProfileCreateNestedOneWithoutAccountInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedCreateWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedCreateWithoutNotificationsInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedCreateNestedOneWithoutAccountInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedCreateNestedManyWithoutAccountInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedCreateNestedManyWithoutRecipientAccountInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedCreateNestedManyWithoutFinancialAccountInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountCreateOrConnectWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountCreateOrConnectWithoutNotificationsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutNotificationsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutNotificationsInputSchema,
        ),
      ]),
    })
    .strict();

export const UserUpsertWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpsertWithoutNotificationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutNotificationsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutNotificationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutNotificationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutNotificationsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUpdateWithoutNotificationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(() => FinancialAccountUpdateManyWithoutCreatorNestedInputSchema)
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () => JointAccountRequestUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutNotificationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      email: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      emailVerified: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      image: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      banned: z
        .union([
          z.boolean(),
          z.lazy(() => NullableBoolFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      banExpires: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profile: z
        .lazy(() => ProfileUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      sessions: z
        .lazy(() => SessionUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      accounts: z
        .lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdAccounts: z
        .lazy(
          () =>
            FinancialAccountUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      accountMemberships: z
        .lazy(() => AccountUserUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      createdJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      receivedJointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutRecipientNestedInputSchema,
        )
        .optional(),
      createdJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutCreatorNestedInputSchema,
        )
        .optional(),
      approvedJointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUpsertWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountUpsertWithoutNotificationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutNotificationsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutNotificationsInputSchema,
        ),
      ]),
      create: z.union([
        z.lazy(() => FinancialAccountCreateWithoutNotificationsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedCreateWithoutNotificationsInputSchema,
        ),
      ]),
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
    })
    .strict();

export const FinancialAccountUpdateToOneWithWhereWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateToOneWithWhereWithoutNotificationsInput> =
  z
    .object({
      where: z.lazy(() => FinancialAccountWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => FinancialAccountUpdateWithoutNotificationsInputSchema),
        z.lazy(
          () => FinancialAccountUncheckedUpdateWithoutNotificationsInputSchema,
        ),
      ]),
    })
    .strict();

export const FinancialAccountUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutNotificationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () => UserUpdateOneRequiredWithoutCreatedAccountsNestedInputSchema,
        )
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutNotificationsInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutNotificationsInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const SessionCreateManyUserInputSchema: z.ZodType<Prisma.SessionCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      impersonatedBy: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountCreateManyUserInputSchema: z.ZodType<Prisma.AccountCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      accountId: z.string(),
      providerId: z.string(),
      accessToken: z.string().optional().nullable(),
      refreshToken: z.string().optional().nullable(),
      accessTokenExpiresAt: z.coerce.date().optional().nullable(),
      refreshTokenExpiresAt: z.coerce.date().optional().nullable(),
      scope: z.string().optional().nullable(),
      idToken: z.string().optional().nullable(),
      password: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const FinancialAccountCreateManyCreatorInputSchema: z.ZodType<Prisma.FinancialAccountCreateManyCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      name: z.string(),
      number: z.string(),
      status: z.lazy(() => AccountStatusSchema).optional(),
      type: z.lazy(() => AccountTypeSchema).optional(),
      ownership: z.lazy(() => AccountOwnershipSchema).optional(),
      balance: z.number().optional(),
      totalTransactions: z.number().int().optional(),
      totalInvestments: z.number().int().optional(),
      firstTransactionAt: z.coerce.date().optional().nullable(),
      lastTransactionAt: z.coerce.date().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      dormantAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUserCreateManyUserInputSchema: z.ZodType<Prisma.AccountUserCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestCreateManyCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestCreateManyCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      recipientId: z.string().optional().nullable(),
      financialAccountId: z.string(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestCreateManyRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestCreateManyRecipientInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      financialAccountId: z.string(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestCreateManyCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyCreatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const NotificationCreateManyUserInputSchema: z.ZodType<Prisma.NotificationCreateManyUserInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      financialAccountId: z.string().optional().nullable(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyApproverInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      jointAccountModRequestId: z.string(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SessionUpdateWithoutUserInputSchema: z.ZodType<Prisma.SessionUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SessionUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.SessionUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      token: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      expiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ipAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      userAgent: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      impersonatedBy: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accessToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accessToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      providerId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      accessToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      accessTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      refreshTokenExpiresAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      scope: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      idToken: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      password: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountUpdateWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUpdateWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(() => BusinessProfileUpdateOneWithoutAccountNestedInputSchema)
        .optional(),
      accountUsers: z
        .lazy(
          () => AccountUserUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () => JointAccountModRequestUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () => NotificationUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      businessProfile: z
        .lazy(
          () =>
            BusinessProfileUncheckedUpdateOneWithoutAccountNestedInputSchema,
        )
        .optional(),
      accountUsers: z
        .lazy(
          () =>
            AccountUserUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountRequests: z
        .lazy(
          () =>
            JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutAccountNestedInputSchema,
        )
        .optional(),
      notifications: z
        .lazy(
          () =>
            NotificationUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
      receivedTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutRecipientAccountNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () =>
            InvestmentUncheckedUpdateManyWithoutFinancialAccountNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const FinancialAccountUncheckedUpdateManyWithoutCreatorInputSchema: z.ZodType<Prisma.FinancialAccountUncheckedUpdateManyWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      name: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      number: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => AccountStatusSchema),
          z.lazy(() => EnumAccountStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => AccountTypeSchema),
          z.lazy(() => EnumAccountTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.lazy(() => AccountOwnershipSchema),
          z.lazy(() => EnumAccountOwnershipFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      balance: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalTransactions: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalInvestments: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      firstTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastTransactionAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      dormantAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutAccountUsersNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInitiatorNestedInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentUpdateManyWithoutInvestorNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedUpdateManyWithoutInitiatorNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedUpdateManyWithoutInvestorNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpdateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipient: z
        .lazy(
          () =>
            UserUpdateOneWithoutReceivedJointAccountRequestsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpdateWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateWithoutRecipientInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountRequestsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateWithoutRecipientInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyWithoutRecipientInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyWithoutRecipientInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpdateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      account: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      transaction: z
        .lazy(
          () =>
            TransactionUpdateOneWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyWithoutCreatorInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyWithoutCreatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationUpdateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccount: z
        .lazy(
          () => FinancialAccountUpdateOneWithoutNotificationsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateWithoutApproverInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      request: z
        .lazy(
          () =>
            JointAccountModRequestUpdateOneRequiredWithoutApprovalsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateWithoutApproverInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequestId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateManyWithoutApproverInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequestId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AccountUserCreateManyFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserCreateManyFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      userId: z.string(),
      role: z.lazy(() => AccountUserRoleSchema).optional(),
      ownership: z.number().optional(),
      autosign: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountRequestCreateManyFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestCreateManyFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      recipientName: z.string(),
      recipientEmail: z.string(),
      role: z.lazy(() => AccountUserRoleSchema),
      ownership: z.number(),
      recipientId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      lastReminderAt: z.coerce.date().optional().nullable(),
      reminderCount: z.number().int().optional(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestCreateManyAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      transactionId: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const NotificationCreateManyFinancialAccountInputSchema: z.ZodType<Prisma.NotificationCreateManyFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      title: z.string(),
      body: z.string(),
      bodyType: z.lazy(() => NotificationBodyTypeSchema).optional(),
      userId: z.string().optional().nullable(),
      link: z.string().optional().nullable(),
      isRead: z.boolean().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const TransactionCreateManyFinancialAccountInputSchema: z.ZodType<Prisma.TransactionCreateManyFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const TransactionCreateManyRecipientAccountInputSchema: z.ZodType<Prisma.TransactionCreateManyRecipientAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentCreateManyFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentCreateManyFinancialAccountInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      investorId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUserUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(
          () => UserUpdateOneRequiredWithoutAccountMembershipsNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInitiatorNestedInputSchema)
        .optional(),
      investments: z
        .lazy(() => InvestmentUpdateManyWithoutInvestorNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () => TransactionUncheckedUpdateManyWithoutInitiatorNestedInputSchema,
        )
        .optional(),
      investments: z
        .lazy(
          () => InvestmentUncheckedUpdateManyWithoutInvestorNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const AccountUserUncheckedUpdateManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.AccountUserUncheckedUpdateManyWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      autosign: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountRequestsNestedInputSchema,
        )
        .optional(),
      recipient: z
        .lazy(
          () =>
            UserUpdateOneWithoutReceivedJointAccountRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.JointAccountRequestUncheckedUpdateManyWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientEmail: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      role: z
        .union([
          z.lazy(() => AccountUserRoleSchema),
          z.lazy(() => EnumAccountUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      ownership: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      lastReminderAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      reminderCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestUpdateWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithoutAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      transaction: z
        .lazy(
          () =>
            TransactionUpdateOneWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateWithoutAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyWithoutAccountInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyWithoutAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      transactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneWithoutNotificationsNestedInputSchema)
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NotificationUncheckedUpdateManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.NotificationUncheckedUpdateManyWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      title: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      body: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      bodyType: z
        .union([
          z.lazy(() => NotificationBodyTypeSchema),
          z.lazy(
            () => EnumNotificationBodyTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      userId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      link: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      isRead: z
        .union([
          z.boolean(),
          z.lazy(() => BoolFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutRecipientAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutRecipientAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutRecipientAccountInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutRecipientAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investor: z
        .lazy(
          () => AccountUserUpdateOneRequiredWithoutInvestmentsNestedInputSchema,
        )
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInvestmentNestedInputSchema)
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutInvestmentNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateManyWithoutFinancialAccountInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateManyWithoutFinancialAccountInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionCreateManyInitiatorInputSchema: z.ZodType<Prisma.TransactionCreateManyInitiatorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const InvestmentCreateManyInvestorInputSchema: z.ZodType<Prisma.InvestmentCreateManyInvestorInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      financialAccountId: z.string(),
      deposit: z.number(),
      investmentName: z.string(),
      totalProfit: z.number().optional(),
      profitCount: z.number().int().optional(),
      status: z.lazy(() => InvestmentStatusSchema).optional(),
      pausedAt: z.coerce.date().optional().nullable(),
      pausedReason: z.string().optional().nullable(),
      closedAt: z.coerce.date().optional().nullable(),
      closedReason: z.string().optional().nullable(),
      terminatedAt: z.coerce.date().optional().nullable(),
      terminatedReason: z.string().optional().nullable(),
      category: z.lazy(() => InvestmentPlanCategorySchema),
      daysCompleted: z.number().int().optional(),
      duration: z.number().int(),
      totalReturn: z.number(),
      periodicReturn: z.number(),
      profitDistribution: z.lazy(() => ProfitDistributionSchema).optional(),
      terminationFee: z.number().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const TransactionUpdateWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutInitiatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutInitiatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutInitiatorInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutInitiatorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const InvestmentUpdateWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUpdateWithoutInvestorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(() => TransactionUpdateManyWithoutInvestmentNestedInputSchema)
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutInvestmentsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateWithoutInvestorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      transactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutInvestmentNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const InvestmentUncheckedUpdateManyWithoutInvestorInputSchema: z.ZodType<Prisma.InvestmentUncheckedUpdateManyWithoutInvestorInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      deposit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      investmentName: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalProfit: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitCount: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvestmentStatusSchema),
          z.lazy(() => EnumInvestmentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      pausedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      pausedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      closedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      terminatedReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      category: z
        .union([
          z.lazy(() => InvestmentPlanCategorySchema),
          z.lazy(
            () => EnumInvestmentPlanCategoryFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      daysCompleted: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      duration: z
        .union([
          z.number().int(),
          z.lazy(() => IntFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      totalReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      periodicReturn: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      profitDistribution: z
        .union([
          z.lazy(() => ProfitDistributionSchema),
          z.lazy(() => EnumProfitDistributionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      terminationFee: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyRequestInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      approverId: z.string(),
      status: z.lazy(() => JointAccountRequestStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateWithoutRequestInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approver: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutApprovedJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateWithoutRequestInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approverId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestInputSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approverId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => JointAccountRequestStatusSchema),
          z.lazy(
            () => EnumJointAccountRequestStatusFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionCreateManyInvestmentInputSchema: z.ZodType<Prisma.TransactionCreateManyInvestmentInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      parentTransactionId: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const TransactionUpdateWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutInvestmentInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      parentTransaction: z
        .lazy(
          () => TransactionUpdateOneWithoutChildTransactionsNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutInvestmentInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutInvestmentInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutInvestmentInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      parentTransactionId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestCreateManyTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyTransactionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      creatorId: z.string(),
      financialAccountId: z.string(),
      type: z.lazy(() => JointAccountModRequestTypeSchema),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const TransactionCreateManyParentTransactionInputSchema: z.ZodType<Prisma.TransactionCreateManyParentTransactionInput> =
  z
    .object({
      id: z.string().uuid().optional(),
      amount: z.number(),
      currency: z.string().optional(),
      USDAmount: z.number(),
      rate: z.number().optional(),
      charges: z.number().optional(),
      financialAccountId: z.string(),
      type: z.lazy(() => TransactionTypeSchema),
      initiatorAccountId: z.string(),
      recipientAccountId: z.string().optional().nullable(),
      investmentId: z.string().optional().nullable(),
      status: z.lazy(() => TransactionStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      failedAt: z.coerce.date().optional().nullable(),
      failReason: z.string().optional().nullable(),
      depositWalletAddress: z.string().optional().nullable(),
      depositWalletAddressNetwork: z.string().optional().nullable(),
      withdrawalWalletAddress: z.string().optional().nullable(),
      withdrawalWalletAddressNetwork: z.string().optional().nullable(),
      bank: z.string().optional().nullable(),
      bankAccount: z.string().optional().nullable(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const JointAccountModRequestUpdateWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUpdateWithoutTransactionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creator: z
        .lazy(
          () =>
            UserUpdateOneRequiredWithoutCreatedJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      account: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutJointAccountModRequestsNestedInputSchema,
        )
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateWithoutTransactionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvals: z
        .lazy(
          () =>
            JointAccountModRequestApprovalUncheckedUpdateManyWithoutRequestNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const JointAccountModRequestUncheckedUpdateManyWithoutTransactionInputSchema: z.ZodType<Prisma.JointAccountModRequestUncheckedUpdateManyWithoutTransactionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      creatorId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => JointAccountModRequestTypeSchema),
          z.lazy(
            () =>
              EnumJointAccountModRequestTypeFieldUpdateOperationsInputSchema,
          ),
        ])
        .optional(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const TransactionUpdateWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUpdateWithoutParentTransactionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiator: z
        .lazy(
          () =>
            AccountUserUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      financialAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneRequiredWithoutTransactionsNestedInputSchema,
        )
        .optional(),
      recipientAccount: z
        .lazy(
          () =>
            FinancialAccountUpdateOneWithoutReceivedTransactionsNestedInputSchema,
        )
        .optional(),
      investment: z
        .lazy(() => InvestmentUpdateOneWithoutTransactionsNestedInputSchema)
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () => TransactionUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateWithoutParentTransactionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      jointAccountModRequests: z
        .lazy(
          () =>
            JointAccountModRequestUncheckedUpdateManyWithoutTransactionNestedInputSchema,
        )
        .optional(),
      childTransactions: z
        .lazy(
          () =>
            TransactionUncheckedUpdateManyWithoutParentTransactionNestedInputSchema,
        )
        .optional(),
    })
    .strict();

export const TransactionUncheckedUpdateManyWithoutParentTransactionInputSchema: z.ZodType<Prisma.TransactionUncheckedUpdateManyWithoutParentTransactionInput> =
  z
    .object({
      id: z
        .union([
          z.string().uuid(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      amount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      currency: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      USDAmount: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      rate: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      charges: z
        .union([
          z.number(),
          z.lazy(() => FloatFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      financialAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => TransactionTypeSchema),
          z.lazy(() => EnumTransactionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      initiatorAccountId: z
        .union([
          z.string(),
          z.lazy(() => StringFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      recipientAccountId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      investmentId: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => TransactionStatusSchema),
          z.lazy(() => EnumTransactionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      failReason: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      depositWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddress: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      withdrawalWalletAddressNetwork: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bank: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      bankAccount: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      description: z
        .union([
          z.string(),
          z.lazy(() => NullableStringFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      updatedAt: z
        .union([
          z.coerce.date(),
          z.lazy(() => DateTimeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

/////////////////////////////////////////
// ARGS
/////////////////////////////////////////

export const UserFindFirstArgsSchema: z.ZodType<Prisma.UserFindFirstArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const UserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserFindFirstOrThrowArgs> =
  z
    .object({
      select: UserSelectSchema.optional(),
      include: UserIncludeSchema.optional(),
      where: UserWhereInputSchema.optional(),
      orderBy: z
        .union([
          UserOrderByWithRelationInputSchema.array(),
          UserOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const UserFindManyArgsSchema: z.ZodType<Prisma.UserFindManyArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const UserAggregateArgsSchema: z.ZodType<Prisma.UserAggregateArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithRelationInputSchema.array(),
        UserOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const UserGroupByArgsSchema: z.ZodType<Prisma.UserGroupByArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([
        UserOrderByWithAggregationInputSchema.array(),
        UserOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: UserScalarFieldEnumSchema.array(),
    having: UserScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const UserFindUniqueArgsSchema: z.ZodType<Prisma.UserFindUniqueArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const UserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserFindUniqueOrThrowArgs> =
  z
    .object({
      select: UserSelectSchema.optional(),
      include: UserIncludeSchema.optional(),
      where: UserWhereUniqueInputSchema,
    })
    .strict();

export const SessionFindFirstArgsSchema: z.ZodType<Prisma.SessionFindFirstArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SessionScalarFieldEnumSchema,
          SessionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SessionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SessionFindFirstOrThrowArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SessionScalarFieldEnumSchema,
          SessionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SessionFindManyArgsSchema: z.ZodType<Prisma.SessionFindManyArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SessionScalarFieldEnumSchema,
          SessionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SessionAggregateArgsSchema: z.ZodType<Prisma.SessionAggregateArgs> =
  z
    .object({
      where: SessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SessionOrderByWithRelationInputSchema.array(),
          SessionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const SessionGroupByArgsSchema: z.ZodType<Prisma.SessionGroupByArgs> = z
  .object({
    where: SessionWhereInputSchema.optional(),
    orderBy: z
      .union([
        SessionOrderByWithAggregationInputSchema.array(),
        SessionOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: SessionScalarFieldEnumSchema.array(),
    having: SessionScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const SessionFindUniqueArgsSchema: z.ZodType<Prisma.SessionFindUniqueArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereUniqueInputSchema,
    })
    .strict();

export const SessionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SessionFindUniqueOrThrowArgs> =
  z
    .object({
      select: SessionSelectSchema.optional(),
      include: SessionIncludeSchema.optional(),
      where: SessionWhereUniqueInputSchema,
    })
    .strict();

export const AccountFindFirstArgsSchema: z.ZodType<Prisma.AccountFindFirstArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountScalarFieldEnumSchema,
          AccountScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const AccountFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AccountFindFirstOrThrowArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountScalarFieldEnumSchema,
          AccountScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const AccountFindManyArgsSchema: z.ZodType<Prisma.AccountFindManyArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountScalarFieldEnumSchema,
          AccountScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const AccountAggregateArgsSchema: z.ZodType<Prisma.AccountAggregateArgs> =
  z
    .object({
      where: AccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountOrderByWithRelationInputSchema.array(),
          AccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const AccountGroupByArgsSchema: z.ZodType<Prisma.AccountGroupByArgs> = z
  .object({
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([
        AccountOrderByWithAggregationInputSchema.array(),
        AccountOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: AccountScalarFieldEnumSchema.array(),
    having: AccountScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const AccountFindUniqueArgsSchema: z.ZodType<Prisma.AccountFindUniqueArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereUniqueInputSchema,
    })
    .strict();

export const AccountFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AccountFindUniqueOrThrowArgs> =
  z
    .object({
      select: AccountSelectSchema.optional(),
      include: AccountIncludeSchema.optional(),
      where: AccountWhereUniqueInputSchema,
    })
    .strict();

export const VerificationFindFirstArgsSchema: z.ZodType<Prisma.VerificationFindFirstArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VerificationScalarFieldEnumSchema,
          VerificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const VerificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.VerificationFindFirstOrThrowArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VerificationScalarFieldEnumSchema,
          VerificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const VerificationFindManyArgsSchema: z.ZodType<Prisma.VerificationFindManyArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          VerificationScalarFieldEnumSchema,
          VerificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const VerificationAggregateArgsSchema: z.ZodType<Prisma.VerificationAggregateArgs> =
  z
    .object({
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithRelationInputSchema.array(),
          VerificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: VerificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const VerificationGroupByArgsSchema: z.ZodType<Prisma.VerificationGroupByArgs> =
  z
    .object({
      where: VerificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          VerificationOrderByWithAggregationInputSchema.array(),
          VerificationOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: VerificationScalarFieldEnumSchema.array(),
      having: VerificationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const VerificationFindUniqueArgsSchema: z.ZodType<Prisma.VerificationFindUniqueArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
    })
    .strict();

export const VerificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.VerificationFindUniqueOrThrowArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
    })
    .strict();

export const ProfileFindFirstArgsSchema: z.ZodType<Prisma.ProfileFindFirstArgs> =
  z
    .object({
      select: ProfileSelectSchema.optional(),
      include: ProfileIncludeSchema.optional(),
      where: ProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProfileOrderByWithRelationInputSchema.array(),
          ProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProfileScalarFieldEnumSchema,
          ProfileScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ProfileFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ProfileFindFirstOrThrowArgs> =
  z
    .object({
      select: ProfileSelectSchema.optional(),
      include: ProfileIncludeSchema.optional(),
      where: ProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProfileOrderByWithRelationInputSchema.array(),
          ProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProfileScalarFieldEnumSchema,
          ProfileScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ProfileFindManyArgsSchema: z.ZodType<Prisma.ProfileFindManyArgs> =
  z
    .object({
      select: ProfileSelectSchema.optional(),
      include: ProfileIncludeSchema.optional(),
      where: ProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProfileOrderByWithRelationInputSchema.array(),
          ProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ProfileScalarFieldEnumSchema,
          ProfileScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ProfileAggregateArgsSchema: z.ZodType<Prisma.ProfileAggregateArgs> =
  z
    .object({
      where: ProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          ProfileOrderByWithRelationInputSchema.array(),
          ProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const ProfileGroupByArgsSchema: z.ZodType<Prisma.ProfileGroupByArgs> = z
  .object({
    where: ProfileWhereInputSchema.optional(),
    orderBy: z
      .union([
        ProfileOrderByWithAggregationInputSchema.array(),
        ProfileOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: ProfileScalarFieldEnumSchema.array(),
    having: ProfileScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ProfileFindUniqueArgsSchema: z.ZodType<Prisma.ProfileFindUniqueArgs> =
  z
    .object({
      select: ProfileSelectSchema.optional(),
      include: ProfileIncludeSchema.optional(),
      where: ProfileWhereUniqueInputSchema,
    })
    .strict();

export const ProfileFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ProfileFindUniqueOrThrowArgs> =
  z
    .object({
      select: ProfileSelectSchema.optional(),
      include: ProfileIncludeSchema.optional(),
      where: ProfileWhereUniqueInputSchema,
    })
    .strict();

export const BusinessProfileFindFirstArgsSchema: z.ZodType<Prisma.BusinessProfileFindFirstArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          BusinessProfileOrderByWithRelationInputSchema.array(),
          BusinessProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: BusinessProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          BusinessProfileScalarFieldEnumSchema,
          BusinessProfileScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileFindFirstOrThrowArgsSchema: z.ZodType<Prisma.BusinessProfileFindFirstOrThrowArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          BusinessProfileOrderByWithRelationInputSchema.array(),
          BusinessProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: BusinessProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          BusinessProfileScalarFieldEnumSchema,
          BusinessProfileScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileFindManyArgsSchema: z.ZodType<Prisma.BusinessProfileFindManyArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          BusinessProfileOrderByWithRelationInputSchema.array(),
          BusinessProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: BusinessProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          BusinessProfileScalarFieldEnumSchema,
          BusinessProfileScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const BusinessProfileAggregateArgsSchema: z.ZodType<Prisma.BusinessProfileAggregateArgs> =
  z
    .object({
      where: BusinessProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          BusinessProfileOrderByWithRelationInputSchema.array(),
          BusinessProfileOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: BusinessProfileWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const BusinessProfileGroupByArgsSchema: z.ZodType<Prisma.BusinessProfileGroupByArgs> =
  z
    .object({
      where: BusinessProfileWhereInputSchema.optional(),
      orderBy: z
        .union([
          BusinessProfileOrderByWithAggregationInputSchema.array(),
          BusinessProfileOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: BusinessProfileScalarFieldEnumSchema.array(),
      having: BusinessProfileScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const BusinessProfileFindUniqueArgsSchema: z.ZodType<Prisma.BusinessProfileFindUniqueArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereUniqueInputSchema,
    })
    .strict();

export const BusinessProfileFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.BusinessProfileFindUniqueOrThrowArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereUniqueInputSchema,
    })
    .strict();

export const FinancialAccountFindFirstArgsSchema: z.ZodType<Prisma.FinancialAccountFindFirstArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          FinancialAccountOrderByWithRelationInputSchema.array(),
          FinancialAccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: FinancialAccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          FinancialAccountScalarFieldEnumSchema,
          FinancialAccountScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountFindFirstOrThrowArgsSchema: z.ZodType<Prisma.FinancialAccountFindFirstOrThrowArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          FinancialAccountOrderByWithRelationInputSchema.array(),
          FinancialAccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: FinancialAccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          FinancialAccountScalarFieldEnumSchema,
          FinancialAccountScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountFindManyArgsSchema: z.ZodType<Prisma.FinancialAccountFindManyArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          FinancialAccountOrderByWithRelationInputSchema.array(),
          FinancialAccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: FinancialAccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          FinancialAccountScalarFieldEnumSchema,
          FinancialAccountScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const FinancialAccountAggregateArgsSchema: z.ZodType<Prisma.FinancialAccountAggregateArgs> =
  z
    .object({
      where: FinancialAccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          FinancialAccountOrderByWithRelationInputSchema.array(),
          FinancialAccountOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: FinancialAccountWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const FinancialAccountGroupByArgsSchema: z.ZodType<Prisma.FinancialAccountGroupByArgs> =
  z
    .object({
      where: FinancialAccountWhereInputSchema.optional(),
      orderBy: z
        .union([
          FinancialAccountOrderByWithAggregationInputSchema.array(),
          FinancialAccountOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: FinancialAccountScalarFieldEnumSchema.array(),
      having: FinancialAccountScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const FinancialAccountFindUniqueArgsSchema: z.ZodType<Prisma.FinancialAccountFindUniqueArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereUniqueInputSchema,
    })
    .strict();

export const FinancialAccountFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.FinancialAccountFindUniqueOrThrowArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereUniqueInputSchema,
    })
    .strict();

export const AccountUserFindFirstArgsSchema: z.ZodType<Prisma.AccountUserFindFirstArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountUserOrderByWithRelationInputSchema.array(),
          AccountUserOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountUserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountUserScalarFieldEnumSchema,
          AccountUserScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AccountUserFindFirstOrThrowArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountUserOrderByWithRelationInputSchema.array(),
          AccountUserOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountUserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountUserScalarFieldEnumSchema,
          AccountUserScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserFindManyArgsSchema: z.ZodType<Prisma.AccountUserFindManyArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountUserOrderByWithRelationInputSchema.array(),
          AccountUserOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountUserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          AccountUserScalarFieldEnumSchema,
          AccountUserScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUserAggregateArgsSchema: z.ZodType<Prisma.AccountUserAggregateArgs> =
  z
    .object({
      where: AccountUserWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountUserOrderByWithRelationInputSchema.array(),
          AccountUserOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AccountUserWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const AccountUserGroupByArgsSchema: z.ZodType<Prisma.AccountUserGroupByArgs> =
  z
    .object({
      where: AccountUserWhereInputSchema.optional(),
      orderBy: z
        .union([
          AccountUserOrderByWithAggregationInputSchema.array(),
          AccountUserOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: AccountUserScalarFieldEnumSchema.array(),
      having: AccountUserScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const AccountUserFindUniqueArgsSchema: z.ZodType<Prisma.AccountUserFindUniqueArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereUniqueInputSchema,
    })
    .strict();

export const AccountUserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AccountUserFindUniqueOrThrowArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountRequestFindFirstArgsSchema: z.ZodType<Prisma.JointAccountRequestFindFirstArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountRequestOrderByWithRelationInputSchema.array(),
          JointAccountRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountRequestScalarFieldEnumSchema,
          JointAccountRequestScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestFindFirstOrThrowArgsSchema: z.ZodType<Prisma.JointAccountRequestFindFirstOrThrowArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountRequestOrderByWithRelationInputSchema.array(),
          JointAccountRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountRequestScalarFieldEnumSchema,
          JointAccountRequestScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestFindManyArgsSchema: z.ZodType<Prisma.JointAccountRequestFindManyArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountRequestOrderByWithRelationInputSchema.array(),
          JointAccountRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountRequestScalarFieldEnumSchema,
          JointAccountRequestScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountRequestAggregateArgsSchema: z.ZodType<Prisma.JointAccountRequestAggregateArgs> =
  z
    .object({
      where: JointAccountRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountRequestOrderByWithRelationInputSchema.array(),
          JointAccountRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const JointAccountRequestGroupByArgsSchema: z.ZodType<Prisma.JointAccountRequestGroupByArgs> =
  z
    .object({
      where: JointAccountRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountRequestOrderByWithAggregationInputSchema.array(),
          JointAccountRequestOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: JointAccountRequestScalarFieldEnumSchema.array(),
      having:
        JointAccountRequestScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const JointAccountRequestFindUniqueArgsSchema: z.ZodType<Prisma.JointAccountRequestFindUniqueArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountRequestFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.JointAccountRequestFindUniqueOrThrowArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestFindFirstArgsSchema: z.ZodType<Prisma.JointAccountModRequestFindFirstArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestOrderByWithRelationInputSchema.array(),
          JointAccountModRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountModRequestScalarFieldEnumSchema,
          JointAccountModRequestScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestFindFirstOrThrowArgsSchema: z.ZodType<Prisma.JointAccountModRequestFindFirstOrThrowArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestOrderByWithRelationInputSchema.array(),
          JointAccountModRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountModRequestScalarFieldEnumSchema,
          JointAccountModRequestScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestFindManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestFindManyArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestOrderByWithRelationInputSchema.array(),
          JointAccountModRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountModRequestScalarFieldEnumSchema,
          JointAccountModRequestScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestAggregateArgsSchema: z.ZodType<Prisma.JointAccountModRequestAggregateArgs> =
  z
    .object({
      where: JointAccountModRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestOrderByWithRelationInputSchema.array(),
          JointAccountModRequestOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestGroupByArgsSchema: z.ZodType<Prisma.JointAccountModRequestGroupByArgs> =
  z
    .object({
      where: JointAccountModRequestWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestOrderByWithAggregationInputSchema.array(),
          JointAccountModRequestOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: JointAccountModRequestScalarFieldEnumSchema.array(),
      having:
        JointAccountModRequestScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestFindUniqueArgsSchema: z.ZodType<Prisma.JointAccountModRequestFindUniqueArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.JointAccountModRequestFindUniqueOrThrowArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestApprovalFindFirstArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalFindFirstArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestApprovalOrderByWithRelationInputSchema.array(),
          JointAccountModRequestApprovalOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestApprovalWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountModRequestApprovalScalarFieldEnumSchema,
          JointAccountModRequestApprovalScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalFindFirstOrThrowArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalFindFirstOrThrowArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestApprovalOrderByWithRelationInputSchema.array(),
          JointAccountModRequestApprovalOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestApprovalWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountModRequestApprovalScalarFieldEnumSchema,
          JointAccountModRequestApprovalScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalFindManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalFindManyArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestApprovalOrderByWithRelationInputSchema.array(),
          JointAccountModRequestApprovalOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestApprovalWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          JointAccountModRequestApprovalScalarFieldEnumSchema,
          JointAccountModRequestApprovalScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const JointAccountModRequestApprovalAggregateArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalAggregateArgs> =
  z
    .object({
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestApprovalOrderByWithRelationInputSchema.array(),
          JointAccountModRequestApprovalOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: JointAccountModRequestApprovalWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalGroupByArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalGroupByArgs> =
  z
    .object({
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      orderBy: z
        .union([
          JointAccountModRequestApprovalOrderByWithAggregationInputSchema.array(),
          JointAccountModRequestApprovalOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: JointAccountModRequestApprovalScalarFieldEnumSchema.array(),
      having:
        JointAccountModRequestApprovalScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalFindUniqueArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalFindUniqueArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestApprovalFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalFindUniqueOrThrowArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentPlanFindFirstArgsSchema: z.ZodType<Prisma.InvestmentPlanFindFirstArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentPlanOrderByWithRelationInputSchema.array(),
          InvestmentPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InvestmentPlanScalarFieldEnumSchema,
          InvestmentPlanScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanFindFirstOrThrowArgsSchema: z.ZodType<Prisma.InvestmentPlanFindFirstOrThrowArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentPlanOrderByWithRelationInputSchema.array(),
          InvestmentPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InvestmentPlanScalarFieldEnumSchema,
          InvestmentPlanScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanFindManyArgsSchema: z.ZodType<Prisma.InvestmentPlanFindManyArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentPlanOrderByWithRelationInputSchema.array(),
          InvestmentPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InvestmentPlanScalarFieldEnumSchema,
          InvestmentPlanScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentPlanAggregateArgsSchema: z.ZodType<Prisma.InvestmentPlanAggregateArgs> =
  z
    .object({
      where: InvestmentPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentPlanOrderByWithRelationInputSchema.array(),
          InvestmentPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const InvestmentPlanGroupByArgsSchema: z.ZodType<Prisma.InvestmentPlanGroupByArgs> =
  z
    .object({
      where: InvestmentPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentPlanOrderByWithAggregationInputSchema.array(),
          InvestmentPlanOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: InvestmentPlanScalarFieldEnumSchema.array(),
      having: InvestmentPlanScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const InvestmentPlanFindUniqueArgsSchema: z.ZodType<Prisma.InvestmentPlanFindUniqueArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentPlanFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.InvestmentPlanFindUniqueOrThrowArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentFindFirstArgsSchema: z.ZodType<Prisma.InvestmentFindFirstArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentOrderByWithRelationInputSchema.array(),
          InvestmentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InvestmentScalarFieldEnumSchema,
          InvestmentScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.InvestmentFindFirstOrThrowArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentOrderByWithRelationInputSchema.array(),
          InvestmentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InvestmentScalarFieldEnumSchema,
          InvestmentScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentFindManyArgsSchema: z.ZodType<Prisma.InvestmentFindManyArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentOrderByWithRelationInputSchema.array(),
          InvestmentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          InvestmentScalarFieldEnumSchema,
          InvestmentScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const InvestmentAggregateArgsSchema: z.ZodType<Prisma.InvestmentAggregateArgs> =
  z
    .object({
      where: InvestmentWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentOrderByWithRelationInputSchema.array(),
          InvestmentOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: InvestmentWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const InvestmentGroupByArgsSchema: z.ZodType<Prisma.InvestmentGroupByArgs> =
  z
    .object({
      where: InvestmentWhereInputSchema.optional(),
      orderBy: z
        .union([
          InvestmentOrderByWithAggregationInputSchema.array(),
          InvestmentOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: InvestmentScalarFieldEnumSchema.array(),
      having: InvestmentScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const InvestmentFindUniqueArgsSchema: z.ZodType<Prisma.InvestmentFindUniqueArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.InvestmentFindUniqueOrThrowArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereUniqueInputSchema,
    })
    .strict();

export const TransactionFindFirstArgsSchema: z.ZodType<Prisma.TransactionFindFirstArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereInputSchema.optional(),
      orderBy: z
        .union([
          TransactionOrderByWithRelationInputSchema.array(),
          TransactionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: TransactionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TransactionScalarFieldEnumSchema,
          TransactionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.TransactionFindFirstOrThrowArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereInputSchema.optional(),
      orderBy: z
        .union([
          TransactionOrderByWithRelationInputSchema.array(),
          TransactionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: TransactionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TransactionScalarFieldEnumSchema,
          TransactionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionFindManyArgsSchema: z.ZodType<Prisma.TransactionFindManyArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereInputSchema.optional(),
      orderBy: z
        .union([
          TransactionOrderByWithRelationInputSchema.array(),
          TransactionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: TransactionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          TransactionScalarFieldEnumSchema,
          TransactionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const TransactionAggregateArgsSchema: z.ZodType<Prisma.TransactionAggregateArgs> =
  z
    .object({
      where: TransactionWhereInputSchema.optional(),
      orderBy: z
        .union([
          TransactionOrderByWithRelationInputSchema.array(),
          TransactionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: TransactionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const TransactionGroupByArgsSchema: z.ZodType<Prisma.TransactionGroupByArgs> =
  z
    .object({
      where: TransactionWhereInputSchema.optional(),
      orderBy: z
        .union([
          TransactionOrderByWithAggregationInputSchema.array(),
          TransactionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: TransactionScalarFieldEnumSchema.array(),
      having: TransactionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const TransactionFindUniqueArgsSchema: z.ZodType<Prisma.TransactionFindUniqueArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereUniqueInputSchema,
    })
    .strict();

export const TransactionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.TransactionFindUniqueOrThrowArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereUniqueInputSchema,
    })
    .strict();

export const NotificationFindFirstArgsSchema: z.ZodType<Prisma.NotificationFindFirstArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NotificationScalarFieldEnumSchema,
          NotificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.NotificationFindFirstOrThrowArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NotificationScalarFieldEnumSchema,
          NotificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationFindManyArgsSchema: z.ZodType<Prisma.NotificationFindManyArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          NotificationScalarFieldEnumSchema,
          NotificationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const NotificationAggregateArgsSchema: z.ZodType<Prisma.NotificationAggregateArgs> =
  z
    .object({
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithRelationInputSchema.array(),
          NotificationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: NotificationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const NotificationGroupByArgsSchema: z.ZodType<Prisma.NotificationGroupByArgs> =
  z
    .object({
      where: NotificationWhereInputSchema.optional(),
      orderBy: z
        .union([
          NotificationOrderByWithAggregationInputSchema.array(),
          NotificationOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: NotificationScalarFieldEnumSchema.array(),
      having: NotificationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const NotificationFindUniqueArgsSchema: z.ZodType<Prisma.NotificationFindUniqueArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict();

export const NotificationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.NotificationFindUniqueOrThrowArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict();

export const CurrencyFindFirstArgsSchema: z.ZodType<Prisma.CurrencyFindFirstArgs> =
  z
    .object({
      select: CurrencySelectSchema.optional(),
      where: CurrencyWhereInputSchema.optional(),
      orderBy: z
        .union([
          CurrencyOrderByWithRelationInputSchema.array(),
          CurrencyOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CurrencyWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CurrencyScalarFieldEnumSchema,
          CurrencyScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CurrencyFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CurrencyFindFirstOrThrowArgs> =
  z
    .object({
      select: CurrencySelectSchema.optional(),
      where: CurrencyWhereInputSchema.optional(),
      orderBy: z
        .union([
          CurrencyOrderByWithRelationInputSchema.array(),
          CurrencyOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CurrencyWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CurrencyScalarFieldEnumSchema,
          CurrencyScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CurrencyFindManyArgsSchema: z.ZodType<Prisma.CurrencyFindManyArgs> =
  z
    .object({
      select: CurrencySelectSchema.optional(),
      where: CurrencyWhereInputSchema.optional(),
      orderBy: z
        .union([
          CurrencyOrderByWithRelationInputSchema.array(),
          CurrencyOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CurrencyWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CurrencyScalarFieldEnumSchema,
          CurrencyScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CurrencyAggregateArgsSchema: z.ZodType<Prisma.CurrencyAggregateArgs> =
  z
    .object({
      where: CurrencyWhereInputSchema.optional(),
      orderBy: z
        .union([
          CurrencyOrderByWithRelationInputSchema.array(),
          CurrencyOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CurrencyWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CurrencyGroupByArgsSchema: z.ZodType<Prisma.CurrencyGroupByArgs> =
  z
    .object({
      where: CurrencyWhereInputSchema.optional(),
      orderBy: z
        .union([
          CurrencyOrderByWithAggregationInputSchema.array(),
          CurrencyOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CurrencyScalarFieldEnumSchema.array(),
      having: CurrencyScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CurrencyFindUniqueArgsSchema: z.ZodType<Prisma.CurrencyFindUniqueArgs> =
  z
    .object({
      select: CurrencySelectSchema.optional(),
      where: CurrencyWhereUniqueInputSchema,
    })
    .strict();

export const CurrencyFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CurrencyFindUniqueOrThrowArgs> =
  z
    .object({
      select: CurrencySelectSchema.optional(),
      where: CurrencyWhereUniqueInputSchema,
    })
    .strict();

export const SettingsFindFirstArgsSchema: z.ZodType<Prisma.SettingsFindFirstArgs> =
  z
    .object({
      select: SettingsSelectSchema.optional(),
      where: SettingsWhereInputSchema.optional(),
      orderBy: z
        .union([
          SettingsOrderByWithRelationInputSchema.array(),
          SettingsOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SettingsWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SettingsScalarFieldEnumSchema,
          SettingsScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SettingsFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SettingsFindFirstOrThrowArgs> =
  z
    .object({
      select: SettingsSelectSchema.optional(),
      where: SettingsWhereInputSchema.optional(),
      orderBy: z
        .union([
          SettingsOrderByWithRelationInputSchema.array(),
          SettingsOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SettingsWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SettingsScalarFieldEnumSchema,
          SettingsScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SettingsFindManyArgsSchema: z.ZodType<Prisma.SettingsFindManyArgs> =
  z
    .object({
      select: SettingsSelectSchema.optional(),
      where: SettingsWhereInputSchema.optional(),
      orderBy: z
        .union([
          SettingsOrderByWithRelationInputSchema.array(),
          SettingsOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SettingsWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SettingsScalarFieldEnumSchema,
          SettingsScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SettingsAggregateArgsSchema: z.ZodType<Prisma.SettingsAggregateArgs> =
  z
    .object({
      where: SettingsWhereInputSchema.optional(),
      orderBy: z
        .union([
          SettingsOrderByWithRelationInputSchema.array(),
          SettingsOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SettingsWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const SettingsGroupByArgsSchema: z.ZodType<Prisma.SettingsGroupByArgs> =
  z
    .object({
      where: SettingsWhereInputSchema.optional(),
      orderBy: z
        .union([
          SettingsOrderByWithAggregationInputSchema.array(),
          SettingsOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: SettingsScalarFieldEnumSchema.array(),
      having: SettingsScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const SettingsFindUniqueArgsSchema: z.ZodType<Prisma.SettingsFindUniqueArgs> =
  z
    .object({
      select: SettingsSelectSchema.optional(),
      where: SettingsWhereUniqueInputSchema,
    })
    .strict();

export const SettingsFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SettingsFindUniqueOrThrowArgs> =
  z
    .object({
      select: SettingsSelectSchema.optional(),
      where: SettingsWhereUniqueInputSchema,
    })
    .strict();

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
  })
  .strict();

export const UserUpsertArgsSchema: z.ZodType<Prisma.UserUpsertArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
    create: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
    update: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
  })
  .strict();

export const UserCreateManyArgsSchema: z.ZodType<Prisma.UserCreateManyArgs> = z
  .object({
    data: z.union([
      UserCreateManyInputSchema,
      UserCreateManyInputSchema.array(),
    ]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const UserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserCreateManyInputSchema,
        UserCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UserDeleteArgsSchema: z.ZodType<Prisma.UserDeleteArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const UserUpdateArgsSchema: z.ZodType<Prisma.UserUpdateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const UserUpdateManyArgsSchema: z.ZodType<Prisma.UserUpdateManyArgs> = z
  .object({
    data: z.union([
      UserUpdateManyMutationInputSchema,
      UserUncheckedUpdateManyInputSchema,
    ]),
    where: UserWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict();

export const UserUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.UserUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        UserUpdateManyMutationInputSchema,
        UserUncheckedUpdateManyInputSchema,
      ]),
      where: UserWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const UserDeleteManyArgsSchema: z.ZodType<Prisma.UserDeleteManyArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    limit: z.number().optional(),
  })
  .strict();

export const SessionCreateArgsSchema: z.ZodType<Prisma.SessionCreateArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    data: z.union([
      SessionCreateInputSchema,
      SessionUncheckedCreateInputSchema,
    ]),
  })
  .strict();

export const SessionUpsertArgsSchema: z.ZodType<Prisma.SessionUpsertArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    where: SessionWhereUniqueInputSchema,
    create: z.union([
      SessionCreateInputSchema,
      SessionUncheckedCreateInputSchema,
    ]),
    update: z.union([
      SessionUpdateInputSchema,
      SessionUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const SessionCreateManyArgsSchema: z.ZodType<Prisma.SessionCreateManyArgs> =
  z
    .object({
      data: z.union([
        SessionCreateManyInputSchema,
        SessionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SessionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SessionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SessionCreateManyInputSchema,
        SessionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SessionDeleteArgsSchema: z.ZodType<Prisma.SessionDeleteArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    where: SessionWhereUniqueInputSchema,
  })
  .strict();

export const SessionUpdateArgsSchema: z.ZodType<Prisma.SessionUpdateArgs> = z
  .object({
    select: SessionSelectSchema.optional(),
    include: SessionIncludeSchema.optional(),
    data: z.union([
      SessionUpdateInputSchema,
      SessionUncheckedUpdateInputSchema,
    ]),
    where: SessionWhereUniqueInputSchema,
  })
  .strict();

export const SessionUpdateManyArgsSchema: z.ZodType<Prisma.SessionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        SessionUpdateManyMutationInputSchema,
        SessionUncheckedUpdateManyInputSchema,
      ]),
      where: SessionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const SessionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SessionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SessionUpdateManyMutationInputSchema,
        SessionUncheckedUpdateManyInputSchema,
      ]),
      where: SessionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const SessionDeleteManyArgsSchema: z.ZodType<Prisma.SessionDeleteManyArgs> =
  z
    .object({
      where: SessionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const AccountCreateArgsSchema: z.ZodType<Prisma.AccountCreateArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    data: z.union([
      AccountCreateInputSchema,
      AccountUncheckedCreateInputSchema,
    ]),
  })
  .strict();

export const AccountUpsertArgsSchema: z.ZodType<Prisma.AccountUpsertArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
    create: z.union([
      AccountCreateInputSchema,
      AccountUncheckedCreateInputSchema,
    ]),
    update: z.union([
      AccountUpdateInputSchema,
      AccountUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const AccountCreateManyArgsSchema: z.ZodType<Prisma.AccountCreateManyArgs> =
  z
    .object({
      data: z.union([
        AccountCreateManyInputSchema,
        AccountCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AccountCreateManyInputSchema,
        AccountCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountDeleteArgsSchema: z.ZodType<Prisma.AccountDeleteArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
  })
  .strict();

export const AccountUpdateArgsSchema: z.ZodType<Prisma.AccountUpdateArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    data: z.union([
      AccountUpdateInputSchema,
      AccountUncheckedUpdateInputSchema,
    ]),
    where: AccountWhereUniqueInputSchema,
  })
  .strict();

export const AccountUpdateManyArgsSchema: z.ZodType<Prisma.AccountUpdateManyArgs> =
  z
    .object({
      data: z.union([
        AccountUpdateManyMutationInputSchema,
        AccountUncheckedUpdateManyInputSchema,
      ]),
      where: AccountWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const AccountUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AccountUpdateManyMutationInputSchema,
        AccountUncheckedUpdateManyInputSchema,
      ]),
      where: AccountWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const AccountDeleteManyArgsSchema: z.ZodType<Prisma.AccountDeleteManyArgs> =
  z
    .object({
      where: AccountWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const VerificationCreateArgsSchema: z.ZodType<Prisma.VerificationCreateArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      data: z.union([
        VerificationCreateInputSchema,
        VerificationUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const VerificationUpsertArgsSchema: z.ZodType<Prisma.VerificationUpsertArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
      create: z.union([
        VerificationCreateInputSchema,
        VerificationUncheckedCreateInputSchema,
      ]),
      update: z.union([
        VerificationUpdateInputSchema,
        VerificationUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const VerificationCreateManyArgsSchema: z.ZodType<Prisma.VerificationCreateManyArgs> =
  z
    .object({
      data: z.union([
        VerificationCreateManyInputSchema,
        VerificationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const VerificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.VerificationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        VerificationCreateManyInputSchema,
        VerificationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const VerificationDeleteArgsSchema: z.ZodType<Prisma.VerificationDeleteArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      where: VerificationWhereUniqueInputSchema,
    })
    .strict();

export const VerificationUpdateArgsSchema: z.ZodType<Prisma.VerificationUpdateArgs> =
  z
    .object({
      select: VerificationSelectSchema.optional(),
      data: z.union([
        VerificationUpdateInputSchema,
        VerificationUncheckedUpdateInputSchema,
      ]),
      where: VerificationWhereUniqueInputSchema,
    })
    .strict();

export const VerificationUpdateManyArgsSchema: z.ZodType<Prisma.VerificationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        VerificationUpdateManyMutationInputSchema,
        VerificationUncheckedUpdateManyInputSchema,
      ]),
      where: VerificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const VerificationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.VerificationUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        VerificationUpdateManyMutationInputSchema,
        VerificationUncheckedUpdateManyInputSchema,
      ]),
      where: VerificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const VerificationDeleteManyArgsSchema: z.ZodType<Prisma.VerificationDeleteManyArgs> =
  z
    .object({
      where: VerificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const ProfileCreateArgsSchema: z.ZodType<Prisma.ProfileCreateArgs> = z
  .object({
    select: ProfileSelectSchema.optional(),
    include: ProfileIncludeSchema.optional(),
    data: z.union([
      ProfileCreateInputSchema,
      ProfileUncheckedCreateInputSchema,
    ]),
  })
  .strict();

export const ProfileUpsertArgsSchema: z.ZodType<Prisma.ProfileUpsertArgs> = z
  .object({
    select: ProfileSelectSchema.optional(),
    include: ProfileIncludeSchema.optional(),
    where: ProfileWhereUniqueInputSchema,
    create: z.union([
      ProfileCreateInputSchema,
      ProfileUncheckedCreateInputSchema,
    ]),
    update: z.union([
      ProfileUpdateInputSchema,
      ProfileUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const ProfileCreateManyArgsSchema: z.ZodType<Prisma.ProfileCreateManyArgs> =
  z
    .object({
      data: z.union([
        ProfileCreateManyInputSchema,
        ProfileCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ProfileCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ProfileCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProfileCreateManyInputSchema,
        ProfileCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ProfileDeleteArgsSchema: z.ZodType<Prisma.ProfileDeleteArgs> = z
  .object({
    select: ProfileSelectSchema.optional(),
    include: ProfileIncludeSchema.optional(),
    where: ProfileWhereUniqueInputSchema,
  })
  .strict();

export const ProfileUpdateArgsSchema: z.ZodType<Prisma.ProfileUpdateArgs> = z
  .object({
    select: ProfileSelectSchema.optional(),
    include: ProfileIncludeSchema.optional(),
    data: z.union([
      ProfileUpdateInputSchema,
      ProfileUncheckedUpdateInputSchema,
    ]),
    where: ProfileWhereUniqueInputSchema,
  })
  .strict();

export const ProfileUpdateManyArgsSchema: z.ZodType<Prisma.ProfileUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ProfileUpdateManyMutationInputSchema,
        ProfileUncheckedUpdateManyInputSchema,
      ]),
      where: ProfileWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const ProfileUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.ProfileUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ProfileUpdateManyMutationInputSchema,
        ProfileUncheckedUpdateManyInputSchema,
      ]),
      where: ProfileWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const ProfileDeleteManyArgsSchema: z.ZodType<Prisma.ProfileDeleteManyArgs> =
  z
    .object({
      where: ProfileWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const BusinessProfileCreateArgsSchema: z.ZodType<Prisma.BusinessProfileCreateArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      data: z.union([
        BusinessProfileCreateInputSchema,
        BusinessProfileUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const BusinessProfileUpsertArgsSchema: z.ZodType<Prisma.BusinessProfileUpsertArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereUniqueInputSchema,
      create: z.union([
        BusinessProfileCreateInputSchema,
        BusinessProfileUncheckedCreateInputSchema,
      ]),
      update: z.union([
        BusinessProfileUpdateInputSchema,
        BusinessProfileUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const BusinessProfileCreateManyArgsSchema: z.ZodType<Prisma.BusinessProfileCreateManyArgs> =
  z
    .object({
      data: z.union([
        BusinessProfileCreateManyInputSchema,
        BusinessProfileCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const BusinessProfileCreateManyAndReturnArgsSchema: z.ZodType<Prisma.BusinessProfileCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        BusinessProfileCreateManyInputSchema,
        BusinessProfileCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const BusinessProfileDeleteArgsSchema: z.ZodType<Prisma.BusinessProfileDeleteArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      where: BusinessProfileWhereUniqueInputSchema,
    })
    .strict();

export const BusinessProfileUpdateArgsSchema: z.ZodType<Prisma.BusinessProfileUpdateArgs> =
  z
    .object({
      select: BusinessProfileSelectSchema.optional(),
      include: BusinessProfileIncludeSchema.optional(),
      data: z.union([
        BusinessProfileUpdateInputSchema,
        BusinessProfileUncheckedUpdateInputSchema,
      ]),
      where: BusinessProfileWhereUniqueInputSchema,
    })
    .strict();

export const BusinessProfileUpdateManyArgsSchema: z.ZodType<Prisma.BusinessProfileUpdateManyArgs> =
  z
    .object({
      data: z.union([
        BusinessProfileUpdateManyMutationInputSchema,
        BusinessProfileUncheckedUpdateManyInputSchema,
      ]),
      where: BusinessProfileWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const BusinessProfileUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.BusinessProfileUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        BusinessProfileUpdateManyMutationInputSchema,
        BusinessProfileUncheckedUpdateManyInputSchema,
      ]),
      where: BusinessProfileWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const BusinessProfileDeleteManyArgsSchema: z.ZodType<Prisma.BusinessProfileDeleteManyArgs> =
  z
    .object({
      where: BusinessProfileWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const FinancialAccountCreateArgsSchema: z.ZodType<Prisma.FinancialAccountCreateArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      data: z.union([
        FinancialAccountCreateInputSchema,
        FinancialAccountUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const FinancialAccountUpsertArgsSchema: z.ZodType<Prisma.FinancialAccountUpsertArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereUniqueInputSchema,
      create: z.union([
        FinancialAccountCreateInputSchema,
        FinancialAccountUncheckedCreateInputSchema,
      ]),
      update: z.union([
        FinancialAccountUpdateInputSchema,
        FinancialAccountUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const FinancialAccountCreateManyArgsSchema: z.ZodType<Prisma.FinancialAccountCreateManyArgs> =
  z
    .object({
      data: z.union([
        FinancialAccountCreateManyInputSchema,
        FinancialAccountCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const FinancialAccountCreateManyAndReturnArgsSchema: z.ZodType<Prisma.FinancialAccountCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        FinancialAccountCreateManyInputSchema,
        FinancialAccountCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const FinancialAccountDeleteArgsSchema: z.ZodType<Prisma.FinancialAccountDeleteArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      where: FinancialAccountWhereUniqueInputSchema,
    })
    .strict();

export const FinancialAccountUpdateArgsSchema: z.ZodType<Prisma.FinancialAccountUpdateArgs> =
  z
    .object({
      select: FinancialAccountSelectSchema.optional(),
      include: FinancialAccountIncludeSchema.optional(),
      data: z.union([
        FinancialAccountUpdateInputSchema,
        FinancialAccountUncheckedUpdateInputSchema,
      ]),
      where: FinancialAccountWhereUniqueInputSchema,
    })
    .strict();

export const FinancialAccountUpdateManyArgsSchema: z.ZodType<Prisma.FinancialAccountUpdateManyArgs> =
  z
    .object({
      data: z.union([
        FinancialAccountUpdateManyMutationInputSchema,
        FinancialAccountUncheckedUpdateManyInputSchema,
      ]),
      where: FinancialAccountWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const FinancialAccountUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.FinancialAccountUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        FinancialAccountUpdateManyMutationInputSchema,
        FinancialAccountUncheckedUpdateManyInputSchema,
      ]),
      where: FinancialAccountWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const FinancialAccountDeleteManyArgsSchema: z.ZodType<Prisma.FinancialAccountDeleteManyArgs> =
  z
    .object({
      where: FinancialAccountWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const AccountUserCreateArgsSchema: z.ZodType<Prisma.AccountUserCreateArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      data: z.union([
        AccountUserCreateInputSchema,
        AccountUserUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const AccountUserUpsertArgsSchema: z.ZodType<Prisma.AccountUserUpsertArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereUniqueInputSchema,
      create: z.union([
        AccountUserCreateInputSchema,
        AccountUserUncheckedCreateInputSchema,
      ]),
      update: z.union([
        AccountUserUpdateInputSchema,
        AccountUserUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const AccountUserCreateManyArgsSchema: z.ZodType<Prisma.AccountUserCreateManyArgs> =
  z
    .object({
      data: z.union([
        AccountUserCreateManyInputSchema,
        AccountUserCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountUserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountUserCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AccountUserCreateManyInputSchema,
        AccountUserCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountUserDeleteArgsSchema: z.ZodType<Prisma.AccountUserDeleteArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      where: AccountUserWhereUniqueInputSchema,
    })
    .strict();

export const AccountUserUpdateArgsSchema: z.ZodType<Prisma.AccountUserUpdateArgs> =
  z
    .object({
      select: AccountUserSelectSchema.optional(),
      include: AccountUserIncludeSchema.optional(),
      data: z.union([
        AccountUserUpdateInputSchema,
        AccountUserUncheckedUpdateInputSchema,
      ]),
      where: AccountUserWhereUniqueInputSchema,
    })
    .strict();

export const AccountUserUpdateManyArgsSchema: z.ZodType<Prisma.AccountUserUpdateManyArgs> =
  z
    .object({
      data: z.union([
        AccountUserUpdateManyMutationInputSchema,
        AccountUserUncheckedUpdateManyInputSchema,
      ]),
      where: AccountUserWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const AccountUserUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountUserUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        AccountUserUpdateManyMutationInputSchema,
        AccountUserUncheckedUpdateManyInputSchema,
      ]),
      where: AccountUserWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const AccountUserDeleteManyArgsSchema: z.ZodType<Prisma.AccountUserDeleteManyArgs> =
  z
    .object({
      where: AccountUserWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountRequestCreateArgsSchema: z.ZodType<Prisma.JointAccountRequestCreateArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      data: z.union([
        JointAccountRequestCreateInputSchema,
        JointAccountRequestUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const JointAccountRequestUpsertArgsSchema: z.ZodType<Prisma.JointAccountRequestUpsertArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereUniqueInputSchema,
      create: z.union([
        JointAccountRequestCreateInputSchema,
        JointAccountRequestUncheckedCreateInputSchema,
      ]),
      update: z.union([
        JointAccountRequestUpdateInputSchema,
        JointAccountRequestUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const JointAccountRequestCreateManyArgsSchema: z.ZodType<Prisma.JointAccountRequestCreateManyArgs> =
  z
    .object({
      data: z.union([
        JointAccountRequestCreateManyInputSchema,
        JointAccountRequestCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountRequestCreateManyAndReturnArgsSchema: z.ZodType<Prisma.JointAccountRequestCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        JointAccountRequestCreateManyInputSchema,
        JointAccountRequestCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountRequestDeleteArgsSchema: z.ZodType<Prisma.JointAccountRequestDeleteArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      where: JointAccountRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountRequestUpdateArgsSchema: z.ZodType<Prisma.JointAccountRequestUpdateArgs> =
  z
    .object({
      select: JointAccountRequestSelectSchema.optional(),
      include: JointAccountRequestIncludeSchema.optional(),
      data: z.union([
        JointAccountRequestUpdateInputSchema,
        JointAccountRequestUncheckedUpdateInputSchema,
      ]),
      where: JointAccountRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountRequestUpdateManyArgsSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyArgs> =
  z
    .object({
      data: z.union([
        JointAccountRequestUpdateManyMutationInputSchema,
        JointAccountRequestUncheckedUpdateManyInputSchema,
      ]),
      where: JointAccountRequestWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountRequestUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.JointAccountRequestUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        JointAccountRequestUpdateManyMutationInputSchema,
        JointAccountRequestUncheckedUpdateManyInputSchema,
      ]),
      where: JointAccountRequestWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountRequestDeleteManyArgsSchema: z.ZodType<Prisma.JointAccountRequestDeleteManyArgs> =
  z
    .object({
      where: JointAccountRequestWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestCreateArgsSchema: z.ZodType<Prisma.JointAccountModRequestCreateArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      data: z.union([
        JointAccountModRequestCreateInputSchema,
        JointAccountModRequestUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const JointAccountModRequestUpsertArgsSchema: z.ZodType<Prisma.JointAccountModRequestUpsertArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereUniqueInputSchema,
      create: z.union([
        JointAccountModRequestCreateInputSchema,
        JointAccountModRequestUncheckedCreateInputSchema,
      ]),
      update: z.union([
        JointAccountModRequestUpdateInputSchema,
        JointAccountModRequestUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const JointAccountModRequestCreateManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestCreateManyInputSchema,
        JointAccountModRequestCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestCreateManyAndReturnArgsSchema: z.ZodType<Prisma.JointAccountModRequestCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestCreateManyInputSchema,
        JointAccountModRequestCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestDeleteArgsSchema: z.ZodType<Prisma.JointAccountModRequestDeleteArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      where: JointAccountModRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestUpdateArgsSchema: z.ZodType<Prisma.JointAccountModRequestUpdateArgs> =
  z
    .object({
      select: JointAccountModRequestSelectSchema.optional(),
      include: JointAccountModRequestIncludeSchema.optional(),
      data: z.union([
        JointAccountModRequestUpdateInputSchema,
        JointAccountModRequestUncheckedUpdateInputSchema,
      ]),
      where: JointAccountModRequestWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestUpdateManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestUpdateManyMutationInputSchema,
        JointAccountModRequestUncheckedUpdateManyInputSchema,
      ]),
      where: JointAccountModRequestWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.JointAccountModRequestUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestUpdateManyMutationInputSchema,
        JointAccountModRequestUncheckedUpdateManyInputSchema,
      ]),
      where: JointAccountModRequestWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestDeleteManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestDeleteManyArgs> =
  z
    .object({
      where: JointAccountModRequestWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      data: z.union([
        JointAccountModRequestApprovalCreateInputSchema,
        JointAccountModRequestApprovalUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalUpsertArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpsertArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereUniqueInputSchema,
      create: z.union([
        JointAccountModRequestApprovalCreateInputSchema,
        JointAccountModRequestApprovalUncheckedCreateInputSchema,
      ]),
      update: z.union([
        JointAccountModRequestApprovalUpdateInputSchema,
        JointAccountModRequestApprovalUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestApprovalCreateManyInputSchema,
        JointAccountModRequestApprovalCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalCreateManyAndReturnArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestApprovalCreateManyInputSchema,
        JointAccountModRequestApprovalCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalDeleteArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalDeleteArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      where: JointAccountModRequestApprovalWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestApprovalUpdateArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateArgs> =
  z
    .object({
      select: JointAccountModRequestApprovalSelectSchema.optional(),
      include: JointAccountModRequestApprovalIncludeSchema.optional(),
      data: z.union([
        JointAccountModRequestApprovalUpdateInputSchema,
        JointAccountModRequestApprovalUncheckedUpdateInputSchema,
      ]),
      where: JointAccountModRequestApprovalWhereUniqueInputSchema,
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestApprovalUpdateManyMutationInputSchema,
        JointAccountModRequestApprovalUncheckedUpdateManyInputSchema,
      ]),
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        JointAccountModRequestApprovalUpdateManyMutationInputSchema,
        JointAccountModRequestApprovalUncheckedUpdateManyInputSchema,
      ]),
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const JointAccountModRequestApprovalDeleteManyArgsSchema: z.ZodType<Prisma.JointAccountModRequestApprovalDeleteManyArgs> =
  z
    .object({
      where: JointAccountModRequestApprovalWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const InvestmentPlanCreateArgsSchema: z.ZodType<Prisma.InvestmentPlanCreateArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      data: z.union([
        InvestmentPlanCreateInputSchema,
        InvestmentPlanUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const InvestmentPlanUpsertArgsSchema: z.ZodType<Prisma.InvestmentPlanUpsertArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereUniqueInputSchema,
      create: z.union([
        InvestmentPlanCreateInputSchema,
        InvestmentPlanUncheckedCreateInputSchema,
      ]),
      update: z.union([
        InvestmentPlanUpdateInputSchema,
        InvestmentPlanUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const InvestmentPlanCreateManyArgsSchema: z.ZodType<Prisma.InvestmentPlanCreateManyArgs> =
  z
    .object({
      data: z.union([
        InvestmentPlanCreateManyInputSchema,
        InvestmentPlanCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const InvestmentPlanCreateManyAndReturnArgsSchema: z.ZodType<Prisma.InvestmentPlanCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InvestmentPlanCreateManyInputSchema,
        InvestmentPlanCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const InvestmentPlanDeleteArgsSchema: z.ZodType<Prisma.InvestmentPlanDeleteArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      where: InvestmentPlanWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentPlanUpdateArgsSchema: z.ZodType<Prisma.InvestmentPlanUpdateArgs> =
  z
    .object({
      select: InvestmentPlanSelectSchema.optional(),
      data: z.union([
        InvestmentPlanUpdateInputSchema,
        InvestmentPlanUncheckedUpdateInputSchema,
      ]),
      where: InvestmentPlanWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentPlanUpdateManyArgsSchema: z.ZodType<Prisma.InvestmentPlanUpdateManyArgs> =
  z
    .object({
      data: z.union([
        InvestmentPlanUpdateManyMutationInputSchema,
        InvestmentPlanUncheckedUpdateManyInputSchema,
      ]),
      where: InvestmentPlanWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const InvestmentPlanUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.InvestmentPlanUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InvestmentPlanUpdateManyMutationInputSchema,
        InvestmentPlanUncheckedUpdateManyInputSchema,
      ]),
      where: InvestmentPlanWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const InvestmentPlanDeleteManyArgsSchema: z.ZodType<Prisma.InvestmentPlanDeleteManyArgs> =
  z
    .object({
      where: InvestmentPlanWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const InvestmentCreateArgsSchema: z.ZodType<Prisma.InvestmentCreateArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      data: z.union([
        InvestmentCreateInputSchema,
        InvestmentUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const InvestmentUpsertArgsSchema: z.ZodType<Prisma.InvestmentUpsertArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereUniqueInputSchema,
      create: z.union([
        InvestmentCreateInputSchema,
        InvestmentUncheckedCreateInputSchema,
      ]),
      update: z.union([
        InvestmentUpdateInputSchema,
        InvestmentUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const InvestmentCreateManyArgsSchema: z.ZodType<Prisma.InvestmentCreateManyArgs> =
  z
    .object({
      data: z.union([
        InvestmentCreateManyInputSchema,
        InvestmentCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const InvestmentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.InvestmentCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InvestmentCreateManyInputSchema,
        InvestmentCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const InvestmentDeleteArgsSchema: z.ZodType<Prisma.InvestmentDeleteArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      where: InvestmentWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentUpdateArgsSchema: z.ZodType<Prisma.InvestmentUpdateArgs> =
  z
    .object({
      select: InvestmentSelectSchema.optional(),
      include: InvestmentIncludeSchema.optional(),
      data: z.union([
        InvestmentUpdateInputSchema,
        InvestmentUncheckedUpdateInputSchema,
      ]),
      where: InvestmentWhereUniqueInputSchema,
    })
    .strict();

export const InvestmentUpdateManyArgsSchema: z.ZodType<Prisma.InvestmentUpdateManyArgs> =
  z
    .object({
      data: z.union([
        InvestmentUpdateManyMutationInputSchema,
        InvestmentUncheckedUpdateManyInputSchema,
      ]),
      where: InvestmentWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const InvestmentUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.InvestmentUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        InvestmentUpdateManyMutationInputSchema,
        InvestmentUncheckedUpdateManyInputSchema,
      ]),
      where: InvestmentWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const InvestmentDeleteManyArgsSchema: z.ZodType<Prisma.InvestmentDeleteManyArgs> =
  z
    .object({
      where: InvestmentWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const TransactionCreateArgsSchema: z.ZodType<Prisma.TransactionCreateArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      data: z.union([
        TransactionCreateInputSchema,
        TransactionUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const TransactionUpsertArgsSchema: z.ZodType<Prisma.TransactionUpsertArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereUniqueInputSchema,
      create: z.union([
        TransactionCreateInputSchema,
        TransactionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        TransactionUpdateInputSchema,
        TransactionUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const TransactionCreateManyArgsSchema: z.ZodType<Prisma.TransactionCreateManyArgs> =
  z
    .object({
      data: z.union([
        TransactionCreateManyInputSchema,
        TransactionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const TransactionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.TransactionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TransactionCreateManyInputSchema,
        TransactionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const TransactionDeleteArgsSchema: z.ZodType<Prisma.TransactionDeleteArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      where: TransactionWhereUniqueInputSchema,
    })
    .strict();

export const TransactionUpdateArgsSchema: z.ZodType<Prisma.TransactionUpdateArgs> =
  z
    .object({
      select: TransactionSelectSchema.optional(),
      include: TransactionIncludeSchema.optional(),
      data: z.union([
        TransactionUpdateInputSchema,
        TransactionUncheckedUpdateInputSchema,
      ]),
      where: TransactionWhereUniqueInputSchema,
    })
    .strict();

export const TransactionUpdateManyArgsSchema: z.ZodType<Prisma.TransactionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        TransactionUpdateManyMutationInputSchema,
        TransactionUncheckedUpdateManyInputSchema,
      ]),
      where: TransactionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const TransactionUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.TransactionUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        TransactionUpdateManyMutationInputSchema,
        TransactionUncheckedUpdateManyInputSchema,
      ]),
      where: TransactionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const TransactionDeleteManyArgsSchema: z.ZodType<Prisma.TransactionDeleteManyArgs> =
  z
    .object({
      where: TransactionWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const NotificationCreateArgsSchema: z.ZodType<Prisma.NotificationCreateArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      data: z.union([
        NotificationCreateInputSchema,
        NotificationUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const NotificationUpsertArgsSchema: z.ZodType<Prisma.NotificationUpsertArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
      create: z.union([
        NotificationCreateInputSchema,
        NotificationUncheckedCreateInputSchema,
      ]),
      update: z.union([
        NotificationUpdateInputSchema,
        NotificationUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const NotificationCreateManyArgsSchema: z.ZodType<Prisma.NotificationCreateManyArgs> =
  z
    .object({
      data: z.union([
        NotificationCreateManyInputSchema,
        NotificationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const NotificationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.NotificationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NotificationCreateManyInputSchema,
        NotificationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const NotificationDeleteArgsSchema: z.ZodType<Prisma.NotificationDeleteArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict();

export const NotificationUpdateArgsSchema: z.ZodType<Prisma.NotificationUpdateArgs> =
  z
    .object({
      select: NotificationSelectSchema.optional(),
      include: NotificationIncludeSchema.optional(),
      data: z.union([
        NotificationUpdateInputSchema,
        NotificationUncheckedUpdateInputSchema,
      ]),
      where: NotificationWhereUniqueInputSchema,
    })
    .strict();

export const NotificationUpdateManyArgsSchema: z.ZodType<Prisma.NotificationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        NotificationUpdateManyMutationInputSchema,
        NotificationUncheckedUpdateManyInputSchema,
      ]),
      where: NotificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const NotificationUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.NotificationUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        NotificationUpdateManyMutationInputSchema,
        NotificationUncheckedUpdateManyInputSchema,
      ]),
      where: NotificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const NotificationDeleteManyArgsSchema: z.ZodType<Prisma.NotificationDeleteManyArgs> =
  z
    .object({
      where: NotificationWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const CurrencyCreateArgsSchema: z.ZodType<Prisma.CurrencyCreateArgs> = z
  .object({
    select: CurrencySelectSchema.optional(),
    data: z.union([
      CurrencyCreateInputSchema,
      CurrencyUncheckedCreateInputSchema,
    ]),
  })
  .strict();

export const CurrencyUpsertArgsSchema: z.ZodType<Prisma.CurrencyUpsertArgs> = z
  .object({
    select: CurrencySelectSchema.optional(),
    where: CurrencyWhereUniqueInputSchema,
    create: z.union([
      CurrencyCreateInputSchema,
      CurrencyUncheckedCreateInputSchema,
    ]),
    update: z.union([
      CurrencyUpdateInputSchema,
      CurrencyUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const CurrencyCreateManyArgsSchema: z.ZodType<Prisma.CurrencyCreateManyArgs> =
  z
    .object({
      data: z.union([
        CurrencyCreateManyInputSchema,
        CurrencyCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CurrencyCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CurrencyCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CurrencyCreateManyInputSchema,
        CurrencyCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CurrencyDeleteArgsSchema: z.ZodType<Prisma.CurrencyDeleteArgs> = z
  .object({
    select: CurrencySelectSchema.optional(),
    where: CurrencyWhereUniqueInputSchema,
  })
  .strict();

export const CurrencyUpdateArgsSchema: z.ZodType<Prisma.CurrencyUpdateArgs> = z
  .object({
    select: CurrencySelectSchema.optional(),
    data: z.union([
      CurrencyUpdateInputSchema,
      CurrencyUncheckedUpdateInputSchema,
    ]),
    where: CurrencyWhereUniqueInputSchema,
  })
  .strict();

export const CurrencyUpdateManyArgsSchema: z.ZodType<Prisma.CurrencyUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CurrencyUpdateManyMutationInputSchema,
        CurrencyUncheckedUpdateManyInputSchema,
      ]),
      where: CurrencyWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const CurrencyUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.CurrencyUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CurrencyUpdateManyMutationInputSchema,
        CurrencyUncheckedUpdateManyInputSchema,
      ]),
      where: CurrencyWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const CurrencyDeleteManyArgsSchema: z.ZodType<Prisma.CurrencyDeleteManyArgs> =
  z
    .object({
      where: CurrencyWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const SettingsCreateArgsSchema: z.ZodType<Prisma.SettingsCreateArgs> = z
  .object({
    select: SettingsSelectSchema.optional(),
    data: z.union([
      SettingsCreateInputSchema,
      SettingsUncheckedCreateInputSchema,
    ]),
  })
  .strict();

export const SettingsUpsertArgsSchema: z.ZodType<Prisma.SettingsUpsertArgs> = z
  .object({
    select: SettingsSelectSchema.optional(),
    where: SettingsWhereUniqueInputSchema,
    create: z.union([
      SettingsCreateInputSchema,
      SettingsUncheckedCreateInputSchema,
    ]),
    update: z.union([
      SettingsUpdateInputSchema,
      SettingsUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const SettingsCreateManyArgsSchema: z.ZodType<Prisma.SettingsCreateManyArgs> =
  z
    .object({
      data: z.union([
        SettingsCreateManyInputSchema,
        SettingsCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SettingsCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SettingsCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SettingsCreateManyInputSchema,
        SettingsCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SettingsDeleteArgsSchema: z.ZodType<Prisma.SettingsDeleteArgs> = z
  .object({
    select: SettingsSelectSchema.optional(),
    where: SettingsWhereUniqueInputSchema,
  })
  .strict();

export const SettingsUpdateArgsSchema: z.ZodType<Prisma.SettingsUpdateArgs> = z
  .object({
    select: SettingsSelectSchema.optional(),
    data: z.union([
      SettingsUpdateInputSchema,
      SettingsUncheckedUpdateInputSchema,
    ]),
    where: SettingsWhereUniqueInputSchema,
  })
  .strict();

export const SettingsUpdateManyArgsSchema: z.ZodType<Prisma.SettingsUpdateManyArgs> =
  z
    .object({
      data: z.union([
        SettingsUpdateManyMutationInputSchema,
        SettingsUncheckedUpdateManyInputSchema,
      ]),
      where: SettingsWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const SettingsUpdateManyAndReturnArgsSchema: z.ZodType<Prisma.SettingsUpdateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SettingsUpdateManyMutationInputSchema,
        SettingsUncheckedUpdateManyInputSchema,
      ]),
      where: SettingsWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();

export const SettingsDeleteManyArgsSchema: z.ZodType<Prisma.SettingsDeleteManyArgs> =
  z
    .object({
      where: SettingsWhereInputSchema.optional(),
      limit: z.number().optional(),
    })
    .strict();
